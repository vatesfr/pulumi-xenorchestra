// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package xenorchestra

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra/internal"
)

// Creates a Xen Orchestra vdi resource.
type Vdi struct {
	pulumi.CustomResourceState

	// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
	Filepath pulumi.StringOutput `pulumi:"filepath"`
	// The name label of the VDI
	NameLabel pulumi.StringOutput `pulumi:"nameLabel"`
	// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
	SrId pulumi.StringOutput `pulumi:"srId"`
	// Only `raw` uploads are supported today, but vhd support may be added in the future.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewVdi registers a new resource with the given unique name, arguments, and options.
func NewVdi(ctx *pulumi.Context,
	name string, args *VdiArgs, opts ...pulumi.ResourceOption) (*Vdi, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Filepath == nil {
		return nil, errors.New("invalid value for required argument 'Filepath'")
	}
	if args.NameLabel == nil {
		return nil, errors.New("invalid value for required argument 'NameLabel'")
	}
	if args.SrId == nil {
		return nil, errors.New("invalid value for required argument 'SrId'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Vdi
	err := ctx.RegisterResource("xenorchestra:index/vdi:Vdi", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVdi gets an existing Vdi resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVdi(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VdiState, opts ...pulumi.ResourceOption) (*Vdi, error) {
	var resource Vdi
	err := ctx.ReadResource("xenorchestra:index/vdi:Vdi", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Vdi resources.
type vdiState struct {
	// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
	Filepath *string `pulumi:"filepath"`
	// The name label of the VDI
	NameLabel *string `pulumi:"nameLabel"`
	// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
	SrId *string `pulumi:"srId"`
	// Only `raw` uploads are supported today, but vhd support may be added in the future.
	Type *string `pulumi:"type"`
}

type VdiState struct {
	// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
	Filepath pulumi.StringPtrInput
	// The name label of the VDI
	NameLabel pulumi.StringPtrInput
	// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
	SrId pulumi.StringPtrInput
	// Only `raw` uploads are supported today, but vhd support may be added in the future.
	Type pulumi.StringPtrInput
}

func (VdiState) ElementType() reflect.Type {
	return reflect.TypeOf((*vdiState)(nil)).Elem()
}

type vdiArgs struct {
	// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
	Filepath string `pulumi:"filepath"`
	// The name label of the VDI
	NameLabel string `pulumi:"nameLabel"`
	// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
	SrId string `pulumi:"srId"`
	// Only `raw` uploads are supported today, but vhd support may be added in the future.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a Vdi resource.
type VdiArgs struct {
	// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
	Filepath pulumi.StringInput
	// The name label of the VDI
	NameLabel pulumi.StringInput
	// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
	SrId pulumi.StringInput
	// Only `raw` uploads are supported today, but vhd support may be added in the future.
	Type pulumi.StringInput
}

func (VdiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vdiArgs)(nil)).Elem()
}

type VdiInput interface {
	pulumi.Input

	ToVdiOutput() VdiOutput
	ToVdiOutputWithContext(ctx context.Context) VdiOutput
}

func (*Vdi) ElementType() reflect.Type {
	return reflect.TypeOf((**Vdi)(nil)).Elem()
}

func (i *Vdi) ToVdiOutput() VdiOutput {
	return i.ToVdiOutputWithContext(context.Background())
}

func (i *Vdi) ToVdiOutputWithContext(ctx context.Context) VdiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VdiOutput)
}

// VdiArrayInput is an input type that accepts VdiArray and VdiArrayOutput values.
// You can construct a concrete instance of `VdiArrayInput` via:
//
//	VdiArray{ VdiArgs{...} }
type VdiArrayInput interface {
	pulumi.Input

	ToVdiArrayOutput() VdiArrayOutput
	ToVdiArrayOutputWithContext(context.Context) VdiArrayOutput
}

type VdiArray []VdiInput

func (VdiArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vdi)(nil)).Elem()
}

func (i VdiArray) ToVdiArrayOutput() VdiArrayOutput {
	return i.ToVdiArrayOutputWithContext(context.Background())
}

func (i VdiArray) ToVdiArrayOutputWithContext(ctx context.Context) VdiArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VdiArrayOutput)
}

// VdiMapInput is an input type that accepts VdiMap and VdiMapOutput values.
// You can construct a concrete instance of `VdiMapInput` via:
//
//	VdiMap{ "key": VdiArgs{...} }
type VdiMapInput interface {
	pulumi.Input

	ToVdiMapOutput() VdiMapOutput
	ToVdiMapOutputWithContext(context.Context) VdiMapOutput
}

type VdiMap map[string]VdiInput

func (VdiMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vdi)(nil)).Elem()
}

func (i VdiMap) ToVdiMapOutput() VdiMapOutput {
	return i.ToVdiMapOutputWithContext(context.Background())
}

func (i VdiMap) ToVdiMapOutputWithContext(ctx context.Context) VdiMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VdiMapOutput)
}

type VdiOutput struct{ *pulumi.OutputState }

func (VdiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Vdi)(nil)).Elem()
}

func (o VdiOutput) ToVdiOutput() VdiOutput {
	return o
}

func (o VdiOutput) ToVdiOutputWithContext(ctx context.Context) VdiOutput {
	return o
}

// The file path to the ISO or vdi image that should be uploaded when the VDI is created.
func (o VdiOutput) Filepath() pulumi.StringOutput {
	return o.ApplyT(func(v *Vdi) pulumi.StringOutput { return v.Filepath }).(pulumi.StringOutput)
}

// The name label of the VDI
func (o VdiOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v *Vdi) pulumi.StringOutput { return v.NameLabel }).(pulumi.StringOutput)
}

// The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.
func (o VdiOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v *Vdi) pulumi.StringOutput { return v.SrId }).(pulumi.StringOutput)
}

// Only `raw` uploads are supported today, but vhd support may be added in the future.
func (o VdiOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Vdi) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type VdiArrayOutput struct{ *pulumi.OutputState }

func (VdiArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vdi)(nil)).Elem()
}

func (o VdiArrayOutput) ToVdiArrayOutput() VdiArrayOutput {
	return o
}

func (o VdiArrayOutput) ToVdiArrayOutputWithContext(ctx context.Context) VdiArrayOutput {
	return o
}

func (o VdiArrayOutput) Index(i pulumi.IntInput) VdiOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Vdi {
		return vs[0].([]*Vdi)[vs[1].(int)]
	}).(VdiOutput)
}

type VdiMapOutput struct{ *pulumi.OutputState }

func (VdiMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vdi)(nil)).Elem()
}

func (o VdiMapOutput) ToVdiMapOutput() VdiMapOutput {
	return o
}

func (o VdiMapOutput) ToVdiMapOutputWithContext(ctx context.Context) VdiMapOutput {
	return o
}

func (o VdiMapOutput) MapIndex(k pulumi.StringInput) VdiOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Vdi {
		return vs[0].(map[string]*Vdi)[vs[1].(string)]
	}).(VdiOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VdiInput)(nil)).Elem(), &Vdi{})
	pulumi.RegisterInputType(reflect.TypeOf((*VdiArrayInput)(nil)).Elem(), VdiArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VdiMapInput)(nil)).Elem(), VdiMap{})
	pulumi.RegisterOutputType(VdiOutput{})
	pulumi.RegisterOutputType(VdiArrayOutput{})
	pulumi.RegisterOutputType(VdiMapOutput{})
}
