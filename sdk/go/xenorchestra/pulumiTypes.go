// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package xenorchestra

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra/internal"
)

var _ = internal.GetEnvOrDefault

type ResourceSetLimit struct {
	// The numerical limit for the given type.
	Quantity int `pulumi:"quantity"`
	// The type of resource set limit. Must be cpus, memory or disk.
	Type string `pulumi:"type"`
}

// ResourceSetLimitInput is an input type that accepts ResourceSetLimitArgs and ResourceSetLimitOutput values.
// You can construct a concrete instance of `ResourceSetLimitInput` via:
//
//	ResourceSetLimitArgs{...}
type ResourceSetLimitInput interface {
	pulumi.Input

	ToResourceSetLimitOutput() ResourceSetLimitOutput
	ToResourceSetLimitOutputWithContext(context.Context) ResourceSetLimitOutput
}

type ResourceSetLimitArgs struct {
	// The numerical limit for the given type.
	Quantity pulumi.IntInput `pulumi:"quantity"`
	// The type of resource set limit. Must be cpus, memory or disk.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ResourceSetLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSetLimit)(nil)).Elem()
}

func (i ResourceSetLimitArgs) ToResourceSetLimitOutput() ResourceSetLimitOutput {
	return i.ToResourceSetLimitOutputWithContext(context.Background())
}

func (i ResourceSetLimitArgs) ToResourceSetLimitOutputWithContext(ctx context.Context) ResourceSetLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSetLimitOutput)
}

// ResourceSetLimitArrayInput is an input type that accepts ResourceSetLimitArray and ResourceSetLimitArrayOutput values.
// You can construct a concrete instance of `ResourceSetLimitArrayInput` via:
//
//	ResourceSetLimitArray{ ResourceSetLimitArgs{...} }
type ResourceSetLimitArrayInput interface {
	pulumi.Input

	ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput
	ToResourceSetLimitArrayOutputWithContext(context.Context) ResourceSetLimitArrayOutput
}

type ResourceSetLimitArray []ResourceSetLimitInput

func (ResourceSetLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSetLimit)(nil)).Elem()
}

func (i ResourceSetLimitArray) ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput {
	return i.ToResourceSetLimitArrayOutputWithContext(context.Background())
}

func (i ResourceSetLimitArray) ToResourceSetLimitArrayOutputWithContext(ctx context.Context) ResourceSetLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceSetLimitArrayOutput)
}

type ResourceSetLimitOutput struct{ *pulumi.OutputState }

func (ResourceSetLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceSetLimit)(nil)).Elem()
}

func (o ResourceSetLimitOutput) ToResourceSetLimitOutput() ResourceSetLimitOutput {
	return o
}

func (o ResourceSetLimitOutput) ToResourceSetLimitOutputWithContext(ctx context.Context) ResourceSetLimitOutput {
	return o
}

// The numerical limit for the given type.
func (o ResourceSetLimitOutput) Quantity() pulumi.IntOutput {
	return o.ApplyT(func(v ResourceSetLimit) int { return v.Quantity }).(pulumi.IntOutput)
}

// The type of resource set limit. Must be cpus, memory or disk.
func (o ResourceSetLimitOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceSetLimit) string { return v.Type }).(pulumi.StringOutput)
}

type ResourceSetLimitArrayOutput struct{ *pulumi.OutputState }

func (ResourceSetLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceSetLimit)(nil)).Elem()
}

func (o ResourceSetLimitArrayOutput) ToResourceSetLimitArrayOutput() ResourceSetLimitArrayOutput {
	return o
}

func (o ResourceSetLimitArrayOutput) ToResourceSetLimitArrayOutputWithContext(ctx context.Context) ResourceSetLimitArrayOutput {
	return o
}

func (o ResourceSetLimitArrayOutput) Index(i pulumi.IntInput) ResourceSetLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceSetLimit {
		return vs[0].([]ResourceSetLimit)[vs[1].(int)]
	}).(ResourceSetLimitOutput)
}

type VmCdrom struct {
	// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
	Id string `pulumi:"id"`
}

// VmCdromInput is an input type that accepts VmCdromArgs and VmCdromOutput values.
// You can construct a concrete instance of `VmCdromInput` via:
//
//	VmCdromArgs{...}
type VmCdromInput interface {
	pulumi.Input

	ToVmCdromOutput() VmCdromOutput
	ToVmCdromOutputWithContext(context.Context) VmCdromOutput
}

type VmCdromArgs struct {
	// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
	Id pulumi.StringInput `pulumi:"id"`
}

func (VmCdromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmCdrom)(nil)).Elem()
}

func (i VmCdromArgs) ToVmCdromOutput() VmCdromOutput {
	return i.ToVmCdromOutputWithContext(context.Background())
}

func (i VmCdromArgs) ToVmCdromOutputWithContext(ctx context.Context) VmCdromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromOutput)
}

func (i VmCdromArgs) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return i.ToVmCdromPtrOutputWithContext(context.Background())
}

func (i VmCdromArgs) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromOutput).ToVmCdromPtrOutputWithContext(ctx)
}

// VmCdromPtrInput is an input type that accepts VmCdromArgs, VmCdromPtr and VmCdromPtrOutput values.
// You can construct a concrete instance of `VmCdromPtrInput` via:
//
//	        VmCdromArgs{...}
//
//	or:
//
//	        nil
type VmCdromPtrInput interface {
	pulumi.Input

	ToVmCdromPtrOutput() VmCdromPtrOutput
	ToVmCdromPtrOutputWithContext(context.Context) VmCdromPtrOutput
}

type vmCdromPtrType VmCdromArgs

func VmCdromPtr(v *VmCdromArgs) VmCdromPtrInput {
	return (*vmCdromPtrType)(v)
}

func (*vmCdromPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VmCdrom)(nil)).Elem()
}

func (i *vmCdromPtrType) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return i.ToVmCdromPtrOutputWithContext(context.Background())
}

func (i *vmCdromPtrType) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmCdromPtrOutput)
}

type VmCdromOutput struct{ *pulumi.OutputState }

func (VmCdromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmCdrom)(nil)).Elem()
}

func (o VmCdromOutput) ToVmCdromOutput() VmCdromOutput {
	return o
}

func (o VmCdromOutput) ToVmCdromOutputWithContext(ctx context.Context) VmCdromOutput {
	return o
}

func (o VmCdromOutput) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return o.ToVmCdromPtrOutputWithContext(context.Background())
}

func (o VmCdromOutput) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VmCdrom) *VmCdrom {
		return &v
	}).(VmCdromPtrOutput)
}

// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
func (o VmCdromOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v VmCdrom) string { return v.Id }).(pulumi.StringOutput)
}

type VmCdromPtrOutput struct{ *pulumi.OutputState }

func (VmCdromPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmCdrom)(nil)).Elem()
}

func (o VmCdromPtrOutput) ToVmCdromPtrOutput() VmCdromPtrOutput {
	return o
}

func (o VmCdromPtrOutput) ToVmCdromPtrOutputWithContext(ctx context.Context) VmCdromPtrOutput {
	return o
}

func (o VmCdromPtrOutput) Elem() VmCdromOutput {
	return o.ApplyT(func(v *VmCdrom) VmCdrom {
		if v != nil {
			return *v
		}
		var ret VmCdrom
		return ret
	}).(VmCdromOutput)
}

// The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.
func (o VmCdromPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmCdrom) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

type VmDisk struct {
	// Whether the device should be attached to the VM.
	Attached *bool `pulumi:"attached"`
	// The description for the disk
	NameDescription *string `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel string `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position *string `pulumi:"position"`
	// The size in bytes for the disk.
	Size float64 `pulumi:"size"`
	// The storage repository ID to use.
	SrId  string  `pulumi:"srId"`
	VbdId *string `pulumi:"vbdId"`
	VdiId *string `pulumi:"vdiId"`
}

// VmDiskInput is an input type that accepts VmDiskArgs and VmDiskOutput values.
// You can construct a concrete instance of `VmDiskInput` via:
//
//	VmDiskArgs{...}
type VmDiskInput interface {
	pulumi.Input

	ToVmDiskOutput() VmDiskOutput
	ToVmDiskOutputWithContext(context.Context) VmDiskOutput
}

type VmDiskArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	// The description for the disk
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position pulumi.StringPtrInput `pulumi:"position"`
	// The size in bytes for the disk.
	Size pulumi.Float64Input `pulumi:"size"`
	// The storage repository ID to use.
	SrId  pulumi.StringInput    `pulumi:"srId"`
	VbdId pulumi.StringPtrInput `pulumi:"vbdId"`
	VdiId pulumi.StringPtrInput `pulumi:"vdiId"`
}

func (VmDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmDisk)(nil)).Elem()
}

func (i VmDiskArgs) ToVmDiskOutput() VmDiskOutput {
	return i.ToVmDiskOutputWithContext(context.Background())
}

func (i VmDiskArgs) ToVmDiskOutputWithContext(ctx context.Context) VmDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmDiskOutput)
}

// VmDiskArrayInput is an input type that accepts VmDiskArray and VmDiskArrayOutput values.
// You can construct a concrete instance of `VmDiskArrayInput` via:
//
//	VmDiskArray{ VmDiskArgs{...} }
type VmDiskArrayInput interface {
	pulumi.Input

	ToVmDiskArrayOutput() VmDiskArrayOutput
	ToVmDiskArrayOutputWithContext(context.Context) VmDiskArrayOutput
}

type VmDiskArray []VmDiskInput

func (VmDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmDisk)(nil)).Elem()
}

func (i VmDiskArray) ToVmDiskArrayOutput() VmDiskArrayOutput {
	return i.ToVmDiskArrayOutputWithContext(context.Background())
}

func (i VmDiskArray) ToVmDiskArrayOutputWithContext(ctx context.Context) VmDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmDiskArrayOutput)
}

type VmDiskOutput struct{ *pulumi.OutputState }

func (VmDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmDisk)(nil)).Elem()
}

func (o VmDiskOutput) ToVmDiskOutput() VmDiskOutput {
	return o
}

func (o VmDiskOutput) ToVmDiskOutputWithContext(ctx context.Context) VmDiskOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o VmDiskOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmDisk) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

// The description for the disk
func (o VmDiskOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name for the disk
func (o VmDiskOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v VmDisk) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Indicates the order of the block device.
func (o VmDiskOutput) Position() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.Position }).(pulumi.StringPtrOutput)
}

// The size in bytes for the disk.
func (o VmDiskOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v VmDisk) float64 { return v.Size }).(pulumi.Float64Output)
}

// The storage repository ID to use.
func (o VmDiskOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v VmDisk) string { return v.SrId }).(pulumi.StringOutput)
}

func (o VmDiskOutput) VbdId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.VbdId }).(pulumi.StringPtrOutput)
}

func (o VmDiskOutput) VdiId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmDisk) *string { return v.VdiId }).(pulumi.StringPtrOutput)
}

type VmDiskArrayOutput struct{ *pulumi.OutputState }

func (VmDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmDisk)(nil)).Elem()
}

func (o VmDiskArrayOutput) ToVmDiskArrayOutput() VmDiskArrayOutput {
	return o
}

func (o VmDiskArrayOutput) ToVmDiskArrayOutputWithContext(ctx context.Context) VmDiskArrayOutput {
	return o
}

func (o VmDiskArrayOutput) Index(i pulumi.IntInput) VmDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmDisk {
		return vs[0].([]VmDisk)[vs[1].(int)]
	}).(VmDiskOutput)
}

type VmNetwork struct {
	// Whether the device should be attached to the VM.
	Attached *bool   `pulumi:"attached"`
	Device   *string `pulumi:"device"`
	// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
	ExpectedIpCidr *string  `pulumi:"expectedIpCidr"`
	Ipv4Addresses  []string `pulumi:"ipv4Addresses"`
	Ipv6Addresses  []string `pulumi:"ipv6Addresses"`
	MacAddress     *string  `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId string `pulumi:"networkId"`
}

// VmNetworkInput is an input type that accepts VmNetworkArgs and VmNetworkOutput values.
// You can construct a concrete instance of `VmNetworkInput` via:
//
//	VmNetworkArgs{...}
type VmNetworkInput interface {
	pulumi.Input

	ToVmNetworkOutput() VmNetworkOutput
	ToVmNetworkOutputWithContext(context.Context) VmNetworkOutput
}

type VmNetworkArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput   `pulumi:"attached"`
	Device   pulumi.StringPtrInput `pulumi:"device"`
	// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
	ExpectedIpCidr pulumi.StringPtrInput   `pulumi:"expectedIpCidr"`
	Ipv4Addresses  pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	Ipv6Addresses  pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	MacAddress     pulumi.StringPtrInput   `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId pulumi.StringInput `pulumi:"networkId"`
}

func (VmNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VmNetwork)(nil)).Elem()
}

func (i VmNetworkArgs) ToVmNetworkOutput() VmNetworkOutput {
	return i.ToVmNetworkOutputWithContext(context.Background())
}

func (i VmNetworkArgs) ToVmNetworkOutputWithContext(ctx context.Context) VmNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmNetworkOutput)
}

// VmNetworkArrayInput is an input type that accepts VmNetworkArray and VmNetworkArrayOutput values.
// You can construct a concrete instance of `VmNetworkArrayInput` via:
//
//	VmNetworkArray{ VmNetworkArgs{...} }
type VmNetworkArrayInput interface {
	pulumi.Input

	ToVmNetworkArrayOutput() VmNetworkArrayOutput
	ToVmNetworkArrayOutputWithContext(context.Context) VmNetworkArrayOutput
}

type VmNetworkArray []VmNetworkInput

func (VmNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmNetwork)(nil)).Elem()
}

func (i VmNetworkArray) ToVmNetworkArrayOutput() VmNetworkArrayOutput {
	return i.ToVmNetworkArrayOutputWithContext(context.Background())
}

func (i VmNetworkArray) ToVmNetworkArrayOutputWithContext(ctx context.Context) VmNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmNetworkArrayOutput)
}

type VmNetworkOutput struct{ *pulumi.OutputState }

func (VmNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VmNetwork)(nil)).Elem()
}

func (o VmNetworkOutput) ToVmNetworkOutput() VmNetworkOutput {
	return o
}

func (o VmNetworkOutput) ToVmNetworkOutputWithContext(ctx context.Context) VmNetworkOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o VmNetworkOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VmNetwork) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

func (o VmNetworkOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.Device }).(pulumi.StringPtrOutput)
}

// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
func (o VmNetworkOutput) ExpectedIpCidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.ExpectedIpCidr }).(pulumi.StringPtrOutput)
}

func (o VmNetworkOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmNetwork) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

func (o VmNetworkOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VmNetwork) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o VmNetworkOutput) MacAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VmNetwork) *string { return v.MacAddress }).(pulumi.StringPtrOutput)
}

// The ID of the network the VM will be on.
func (o VmNetworkOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v VmNetwork) string { return v.NetworkId }).(pulumi.StringOutput)
}

type VmNetworkArrayOutput struct{ *pulumi.OutputState }

func (VmNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VmNetwork)(nil)).Elem()
}

func (o VmNetworkArrayOutput) ToVmNetworkArrayOutput() VmNetworkArrayOutput {
	return o
}

func (o VmNetworkArrayOutput) ToVmNetworkArrayOutputWithContext(ctx context.Context) VmNetworkArrayOutput {
	return o
}

func (o VmNetworkArrayOutput) Index(i pulumi.IntInput) VmNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VmNetwork {
		return vs[0].([]VmNetwork)[vs[1].(int)]
	}).(VmNetworkOutput)
}

type GetXoaHostsHost struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus map[string]int `pulumi:"cpus"`
	Id   string         `pulumi:"id"`
	// The memory size of the host.
	Memory int `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage int `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel string `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId string `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
}

// GetXoaHostsHostInput is an input type that accepts GetXoaHostsHostArgs and GetXoaHostsHostOutput values.
// You can construct a concrete instance of `GetXoaHostsHostInput` via:
//
//	GetXoaHostsHostArgs{...}
type GetXoaHostsHostInput interface {
	pulumi.Input

	ToGetXoaHostsHostOutput() GetXoaHostsHostOutput
	ToGetXoaHostsHostOutputWithContext(context.Context) GetXoaHostsHostOutput
}

type GetXoaHostsHostArgs struct {
	// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
	Cpus pulumi.IntMapInput `pulumi:"cpus"`
	Id   pulumi.StringInput `pulumi:"id"`
	// The memory size of the host.
	Memory pulumi.IntInput `pulumi:"memory"`
	// The memory usage of the host.
	MemoryUsage pulumi.IntInput `pulumi:"memoryUsage"`
	// The name label of the host.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Id of the pool that the host belongs to.
	PoolId pulumi.StringInput `pulumi:"poolId"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
}

func (GetXoaHostsHostArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaHostsHost)(nil)).Elem()
}

func (i GetXoaHostsHostArgs) ToGetXoaHostsHostOutput() GetXoaHostsHostOutput {
	return i.ToGetXoaHostsHostOutputWithContext(context.Background())
}

func (i GetXoaHostsHostArgs) ToGetXoaHostsHostOutputWithContext(ctx context.Context) GetXoaHostsHostOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaHostsHostOutput)
}

// GetXoaHostsHostArrayInput is an input type that accepts GetXoaHostsHostArray and GetXoaHostsHostArrayOutput values.
// You can construct a concrete instance of `GetXoaHostsHostArrayInput` via:
//
//	GetXoaHostsHostArray{ GetXoaHostsHostArgs{...} }
type GetXoaHostsHostArrayInput interface {
	pulumi.Input

	ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput
	ToGetXoaHostsHostArrayOutputWithContext(context.Context) GetXoaHostsHostArrayOutput
}

type GetXoaHostsHostArray []GetXoaHostsHostInput

func (GetXoaHostsHostArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaHostsHost)(nil)).Elem()
}

func (i GetXoaHostsHostArray) ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput {
	return i.ToGetXoaHostsHostArrayOutputWithContext(context.Background())
}

func (i GetXoaHostsHostArray) ToGetXoaHostsHostArrayOutputWithContext(ctx context.Context) GetXoaHostsHostArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaHostsHostArrayOutput)
}

type GetXoaHostsHostOutput struct{ *pulumi.OutputState }

func (GetXoaHostsHostOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaHostsHost)(nil)).Elem()
}

func (o GetXoaHostsHostOutput) ToGetXoaHostsHostOutput() GetXoaHostsHostOutput {
	return o
}

func (o GetXoaHostsHostOutput) ToGetXoaHostsHostOutputWithContext(ctx context.Context) GetXoaHostsHostOutput {
	return o
}

// CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.
func (o GetXoaHostsHostOutput) Cpus() pulumi.IntMapOutput {
	return o.ApplyT(func(v GetXoaHostsHost) map[string]int { return v.Cpus }).(pulumi.IntMapOutput)
}

func (o GetXoaHostsHostOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.Id }).(pulumi.StringOutput)
}

// The memory size of the host.
func (o GetXoaHostsHostOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaHostsHost) int { return v.Memory }).(pulumi.IntOutput)
}

// The memory usage of the host.
func (o GetXoaHostsHostOutput) MemoryUsage() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaHostsHost) int { return v.MemoryUsage }).(pulumi.IntOutput)
}

// The name label of the host.
func (o GetXoaHostsHostOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Id of the pool that the host belongs to.
func (o GetXoaHostsHostOutput) PoolId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaHostsHost) string { return v.PoolId }).(pulumi.StringOutput)
}

// The tags (labels) applied to the given entity.
func (o GetXoaHostsHostOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaHostsHost) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

type GetXoaHostsHostArrayOutput struct{ *pulumi.OutputState }

func (GetXoaHostsHostArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaHostsHost)(nil)).Elem()
}

func (o GetXoaHostsHostArrayOutput) ToGetXoaHostsHostArrayOutput() GetXoaHostsHostArrayOutput {
	return o
}

func (o GetXoaHostsHostArrayOutput) ToGetXoaHostsHostArrayOutputWithContext(ctx context.Context) GetXoaHostsHostArrayOutput {
	return o
}

func (o GetXoaHostsHostArrayOutput) Index(i pulumi.IntInput) GetXoaHostsHostOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaHostsHost {
		return vs[0].([]GetXoaHostsHost)[vs[1].(int)]
	}).(GetXoaHostsHostOutput)
}

type GetXoaVmsVm struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost *string `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron *bool `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. See: https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
	BlockedOperations []string `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType *string `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig *string `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig *string `pulumi:"cloudNetworkConfig"`
	CoreOs             *bool   `pulumi:"coreOs"`
	CpuCap             *int    `pulumi:"cpuCap"`
	CpuWeight          *int    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus int `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks []GetXoaVmsVmDisk `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm *bool `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability *string `pulumi:"highAvailability"`
	Host             *string `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware *string  `pulumi:"hvmBootFirmware"`
	Id              string   `pulumi:"id"`
	Ipv4Addresses   []string `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM. While the output contains a list of ipv6 addresses, the presence of an IP address is only guaranteed if `expectedIpCidr` is set for that interface. The list contains the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses []string `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax int `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription *string `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel string `pulumi:"nameLabel"`
	// The network for the VM.
	Networks []GetXoaVmsVmNetwork `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  *string `pulumi:"powerState"`
	ResourceSet *string `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay *int `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags []string `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template string `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga *string `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram *int `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore map[string]string `pulumi:"xenstore"`
}

// GetXoaVmsVmInput is an input type that accepts GetXoaVmsVmArgs and GetXoaVmsVmOutput values.
// You can construct a concrete instance of `GetXoaVmsVmInput` via:
//
//	GetXoaVmsVmArgs{...}
type GetXoaVmsVmInput interface {
	pulumi.Input

	ToGetXoaVmsVmOutput() GetXoaVmsVmOutput
	ToGetXoaVmsVmOutputWithContext(context.Context) GetXoaVmsVmOutput
}

type GetXoaVmsVmArgs struct {
	// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
	AffinityHost pulumi.StringPtrInput `pulumi:"affinityHost"`
	// If the VM will automatically turn on. Defaults to `false`.
	AutoPoweron pulumi.BoolPtrInput `pulumi:"autoPoweron"`
	// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. See: https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
	BlockedOperations pulumi.StringArrayInput `pulumi:"blockedOperations"`
	// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
	CloneType pulumi.StringPtrInput `pulumi:"cloneType"`
	// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
	CloudConfig pulumi.StringPtrInput `pulumi:"cloudConfig"`
	// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
	CloudNetworkConfig pulumi.StringPtrInput `pulumi:"cloudNetworkConfig"`
	CoreOs             pulumi.BoolPtrInput   `pulumi:"coreOs"`
	CpuCap             pulumi.IntPtrInput    `pulumi:"cpuCap"`
	CpuWeight          pulumi.IntPtrInput    `pulumi:"cpuWeight"`
	// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
	Cpus pulumi.IntInput `pulumi:"cpus"`
	// The disk the VM will have access to.
	Disks GetXoaVmsVmDiskArrayInput `pulumi:"disks"`
	// Boolean parameter that allows a VM to use nested virtualization.
	ExpNestedHvm pulumi.BoolPtrInput `pulumi:"expNestedHvm"`
	// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
	HighAvailability pulumi.StringPtrInput `pulumi:"highAvailability"`
	Host             pulumi.StringPtrInput `pulumi:"host"`
	// The firmware to use for the VM. Possible values are `bios` and `uefi`.
	HvmBootFirmware pulumi.StringPtrInput   `pulumi:"hvmBootFirmware"`
	Id              pulumi.StringInput      `pulumi:"id"`
	Ipv4Addresses   pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	// This is only accessible if guest-tools is installed in the VM. While the output contains a list of ipv6 addresses, the presence of an IP address is only guaranteed if `expectedIpCidr` is set for that interface. The list contains the ipv6 addresses across all network interfaces in order.
	Ipv6Addresses pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
	MemoryMax pulumi.IntInput `pulumi:"memoryMax"`
	// The description of the VM.
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name of the VM.
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// The network for the VM.
	Networks GetXoaVmsVmNetworkArrayInput `pulumi:"networks"`
	// The power state of the VM. This can be Running, Halted, Paused or Suspended.
	PowerState  pulumi.StringPtrInput `pulumi:"powerState"`
	ResourceSet pulumi.StringPtrInput `pulumi:"resourceSet"`
	// Number of seconds the VM should be delayed from starting.
	StartDelay pulumi.IntPtrInput `pulumi:"startDelay"`
	// The tags (labels) applied to the given entity.
	Tags pulumi.StringArrayInput `pulumi:"tags"`
	// The ID of the VM template to create the new VM from.
	Template pulumi.StringInput `pulumi:"template"`
	// The video adapter the VM should use. Possible values include std and cirrus.
	Vga pulumi.StringPtrInput `pulumi:"vga"`
	// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
	Videoram pulumi.IntPtrInput `pulumi:"videoram"`
	// The key value pairs to be populated in xenstore.
	Xenstore pulumi.StringMapInput `pulumi:"xenstore"`
}

func (GetXoaVmsVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVm)(nil)).Elem()
}

func (i GetXoaVmsVmArgs) ToGetXoaVmsVmOutput() GetXoaVmsVmOutput {
	return i.ToGetXoaVmsVmOutputWithContext(context.Background())
}

func (i GetXoaVmsVmArgs) ToGetXoaVmsVmOutputWithContext(ctx context.Context) GetXoaVmsVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmOutput)
}

// GetXoaVmsVmArrayInput is an input type that accepts GetXoaVmsVmArray and GetXoaVmsVmArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmArrayInput` via:
//
//	GetXoaVmsVmArray{ GetXoaVmsVmArgs{...} }
type GetXoaVmsVmArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput
	ToGetXoaVmsVmArrayOutputWithContext(context.Context) GetXoaVmsVmArrayOutput
}

type GetXoaVmsVmArray []GetXoaVmsVmInput

func (GetXoaVmsVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVm)(nil)).Elem()
}

func (i GetXoaVmsVmArray) ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput {
	return i.ToGetXoaVmsVmArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmArray) ToGetXoaVmsVmArrayOutputWithContext(ctx context.Context) GetXoaVmsVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmArrayOutput)
}

type GetXoaVmsVmOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVm)(nil)).Elem()
}

func (o GetXoaVmsVmOutput) ToGetXoaVmsVmOutput() GetXoaVmsVmOutput {
	return o
}

func (o GetXoaVmsVmOutput) ToGetXoaVmsVmOutputWithContext(ctx context.Context) GetXoaVmsVmOutput {
	return o
}

// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.
func (o GetXoaVmsVmOutput) AffinityHost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.AffinityHost }).(pulumi.StringPtrOutput)
}

// If the VM will automatically turn on. Defaults to `false`.
func (o GetXoaVmsVmOutput) AutoPoweron() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.AutoPoweron }).(pulumi.BoolPtrOutput)
}

// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. See: https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
func (o GetXoaVmsVmOutput) BlockedOperations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.BlockedOperations }).(pulumi.StringArrayOutput)
}

// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.
func (o GetXoaVmsVmOutput) CloneType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloneType }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
func (o GetXoaVmsVmOutput) CloudConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloudConfig }).(pulumi.StringPtrOutput)
}

// The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
func (o GetXoaVmsVmOutput) CloudNetworkConfig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.CloudNetworkConfig }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) CoreOs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.CoreOs }).(pulumi.BoolPtrOutput)
}

func (o GetXoaVmsVmOutput) CpuCap() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.CpuCap }).(pulumi.IntPtrOutput)
}

func (o GetXoaVmsVmOutput) CpuWeight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.CpuWeight }).(pulumi.IntPtrOutput)
}

// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:
func (o GetXoaVmsVmOutput) Cpus() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVm) int { return v.Cpus }).(pulumi.IntOutput)
}

// The disk the VM will have access to.
func (o GetXoaVmsVmOutput) Disks() GetXoaVmsVmDiskArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []GetXoaVmsVmDisk { return v.Disks }).(GetXoaVmsVmDiskArrayOutput)
}

// Boolean parameter that allows a VM to use nested virtualization.
func (o GetXoaVmsVmOutput) ExpNestedHvm() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *bool { return v.ExpNestedHvm }).(pulumi.BoolPtrOutput)
}

// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string
func (o GetXoaVmsVmOutput) HighAvailability() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.HighAvailability }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// The firmware to use for the VM. Possible values are `bios` and `uefi`.
func (o GetXoaVmsVmOutput) HvmBootFirmware() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.HvmBootFirmware }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.Id }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

// This is only accessible if guest-tools is installed in the VM. While the output contains a list of ipv6 addresses, the presence of an IP address is only guaranteed if `expectedIpCidr` is set for that interface. The list contains the ipv6 addresses across all network interfaces in order.
func (o GetXoaVmsVmOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

// The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:
func (o GetXoaVmsVmOutput) MemoryMax() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVm) int { return v.MemoryMax }).(pulumi.IntOutput)
}

// The description of the VM.
func (o GetXoaVmsVmOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name of the VM.
func (o GetXoaVmsVmOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.NameLabel }).(pulumi.StringOutput)
}

// The network for the VM.
func (o GetXoaVmsVmOutput) Networks() GetXoaVmsVmNetworkArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []GetXoaVmsVmNetwork { return v.Networks }).(GetXoaVmsVmNetworkArrayOutput)
}

// The power state of the VM. This can be Running, Halted, Paused or Suspended.
func (o GetXoaVmsVmOutput) PowerState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.PowerState }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmOutput) ResourceSet() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.ResourceSet }).(pulumi.StringPtrOutput)
}

// Number of seconds the VM should be delayed from starting.
func (o GetXoaVmsVmOutput) StartDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.StartDelay }).(pulumi.IntPtrOutput)
}

// The tags (labels) applied to the given entity.
func (o GetXoaVmsVmOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVm) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

// The ID of the VM template to create the new VM from.
func (o GetXoaVmsVmOutput) Template() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVm) string { return v.Template }).(pulumi.StringOutput)
}

// The video adapter the VM should use. Possible values include std and cirrus.
func (o GetXoaVmsVmOutput) Vga() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *string { return v.Vga }).(pulumi.StringPtrOutput)
}

// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
func (o GetXoaVmsVmOutput) Videoram() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVm) *int { return v.Videoram }).(pulumi.IntPtrOutput)
}

// The key value pairs to be populated in xenstore.
func (o GetXoaVmsVmOutput) Xenstore() pulumi.StringMapOutput {
	return o.ApplyT(func(v GetXoaVmsVm) map[string]string { return v.Xenstore }).(pulumi.StringMapOutput)
}

type GetXoaVmsVmArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVm)(nil)).Elem()
}

func (o GetXoaVmsVmArrayOutput) ToGetXoaVmsVmArrayOutput() GetXoaVmsVmArrayOutput {
	return o
}

func (o GetXoaVmsVmArrayOutput) ToGetXoaVmsVmArrayOutputWithContext(ctx context.Context) GetXoaVmsVmArrayOutput {
	return o
}

func (o GetXoaVmsVmArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVm {
		return vs[0].([]GetXoaVmsVm)[vs[1].(int)]
	}).(GetXoaVmsVmOutput)
}

type GetXoaVmsVmDisk struct {
	// Whether the device should be attached to the VM.
	Attached *bool `pulumi:"attached"`
	// The description for the disk
	NameDescription *string `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel string `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position string `pulumi:"position"`
	// The size in bytes for the disk.
	Size int `pulumi:"size"`
	// The storage repository ID to use.
	SrId  string `pulumi:"srId"`
	VbdId string `pulumi:"vbdId"`
	VdiId string `pulumi:"vdiId"`
}

// GetXoaVmsVmDiskInput is an input type that accepts GetXoaVmsVmDiskArgs and GetXoaVmsVmDiskOutput values.
// You can construct a concrete instance of `GetXoaVmsVmDiskInput` via:
//
//	GetXoaVmsVmDiskArgs{...}
type GetXoaVmsVmDiskInput interface {
	pulumi.Input

	ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput
	ToGetXoaVmsVmDiskOutputWithContext(context.Context) GetXoaVmsVmDiskOutput
}

type GetXoaVmsVmDiskArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	// The description for the disk
	NameDescription pulumi.StringPtrInput `pulumi:"nameDescription"`
	// The name for the disk
	NameLabel pulumi.StringInput `pulumi:"nameLabel"`
	// Indicates the order of the block device.
	Position pulumi.StringInput `pulumi:"position"`
	// The size in bytes for the disk.
	Size pulumi.IntInput `pulumi:"size"`
	// The storage repository ID to use.
	SrId  pulumi.StringInput `pulumi:"srId"`
	VbdId pulumi.StringInput `pulumi:"vbdId"`
	VdiId pulumi.StringInput `pulumi:"vdiId"`
}

func (GetXoaVmsVmDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmDisk)(nil)).Elem()
}

func (i GetXoaVmsVmDiskArgs) ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput {
	return i.ToGetXoaVmsVmDiskOutputWithContext(context.Background())
}

func (i GetXoaVmsVmDiskArgs) ToGetXoaVmsVmDiskOutputWithContext(ctx context.Context) GetXoaVmsVmDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmDiskOutput)
}

// GetXoaVmsVmDiskArrayInput is an input type that accepts GetXoaVmsVmDiskArray and GetXoaVmsVmDiskArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmDiskArrayInput` via:
//
//	GetXoaVmsVmDiskArray{ GetXoaVmsVmDiskArgs{...} }
type GetXoaVmsVmDiskArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput
	ToGetXoaVmsVmDiskArrayOutputWithContext(context.Context) GetXoaVmsVmDiskArrayOutput
}

type GetXoaVmsVmDiskArray []GetXoaVmsVmDiskInput

func (GetXoaVmsVmDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmDisk)(nil)).Elem()
}

func (i GetXoaVmsVmDiskArray) ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput {
	return i.ToGetXoaVmsVmDiskArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmDiskArray) ToGetXoaVmsVmDiskArrayOutputWithContext(ctx context.Context) GetXoaVmsVmDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmDiskArrayOutput)
}

type GetXoaVmsVmDiskOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmDisk)(nil)).Elem()
}

func (o GetXoaVmsVmDiskOutput) ToGetXoaVmsVmDiskOutput() GetXoaVmsVmDiskOutput {
	return o
}

func (o GetXoaVmsVmDiskOutput) ToGetXoaVmsVmDiskOutputWithContext(ctx context.Context) GetXoaVmsVmDiskOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetXoaVmsVmDiskOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

// The description for the disk
func (o GetXoaVmsVmDiskOutput) NameDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) *string { return v.NameDescription }).(pulumi.StringPtrOutput)
}

// The name for the disk
func (o GetXoaVmsVmDiskOutput) NameLabel() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.NameLabel }).(pulumi.StringOutput)
}

// Indicates the order of the block device.
func (o GetXoaVmsVmDiskOutput) Position() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.Position }).(pulumi.StringOutput)
}

// The size in bytes for the disk.
func (o GetXoaVmsVmDiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) int { return v.Size }).(pulumi.IntOutput)
}

// The storage repository ID to use.
func (o GetXoaVmsVmDiskOutput) SrId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.SrId }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmDiskOutput) VbdId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.VbdId }).(pulumi.StringOutput)
}

func (o GetXoaVmsVmDiskOutput) VdiId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmDisk) string { return v.VdiId }).(pulumi.StringOutput)
}

type GetXoaVmsVmDiskArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmDisk)(nil)).Elem()
}

func (o GetXoaVmsVmDiskArrayOutput) ToGetXoaVmsVmDiskArrayOutput() GetXoaVmsVmDiskArrayOutput {
	return o
}

func (o GetXoaVmsVmDiskArrayOutput) ToGetXoaVmsVmDiskArrayOutputWithContext(ctx context.Context) GetXoaVmsVmDiskArrayOutput {
	return o
}

func (o GetXoaVmsVmDiskArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVmDisk {
		return vs[0].([]GetXoaVmsVmDisk)[vs[1].(int)]
	}).(GetXoaVmsVmDiskOutput)
}

type GetXoaVmsVmNetwork struct {
	// Whether the device should be attached to the VM.
	Attached *bool  `pulumi:"attached"`
	Device   string `pulumi:"device"`
	// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
	ExpectedIpCidr *string  `pulumi:"expectedIpCidr"`
	Ipv4Addresses  []string `pulumi:"ipv4Addresses"`
	Ipv6Addresses  []string `pulumi:"ipv6Addresses"`
	MacAddress     string   `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId string `pulumi:"networkId"`
}

// GetXoaVmsVmNetworkInput is an input type that accepts GetXoaVmsVmNetworkArgs and GetXoaVmsVmNetworkOutput values.
// You can construct a concrete instance of `GetXoaVmsVmNetworkInput` via:
//
//	GetXoaVmsVmNetworkArgs{...}
type GetXoaVmsVmNetworkInput interface {
	pulumi.Input

	ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput
	ToGetXoaVmsVmNetworkOutputWithContext(context.Context) GetXoaVmsVmNetworkOutput
}

type GetXoaVmsVmNetworkArgs struct {
	// Whether the device should be attached to the VM.
	Attached pulumi.BoolPtrInput `pulumi:"attached"`
	Device   pulumi.StringInput  `pulumi:"device"`
	// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
	ExpectedIpCidr pulumi.StringPtrInput   `pulumi:"expectedIpCidr"`
	Ipv4Addresses  pulumi.StringArrayInput `pulumi:"ipv4Addresses"`
	Ipv6Addresses  pulumi.StringArrayInput `pulumi:"ipv6Addresses"`
	MacAddress     pulumi.StringInput      `pulumi:"macAddress"`
	// The ID of the network the VM will be on.
	NetworkId pulumi.StringInput `pulumi:"networkId"`
}

func (GetXoaVmsVmNetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmNetwork)(nil)).Elem()
}

func (i GetXoaVmsVmNetworkArgs) ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput {
	return i.ToGetXoaVmsVmNetworkOutputWithContext(context.Background())
}

func (i GetXoaVmsVmNetworkArgs) ToGetXoaVmsVmNetworkOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmNetworkOutput)
}

// GetXoaVmsVmNetworkArrayInput is an input type that accepts GetXoaVmsVmNetworkArray and GetXoaVmsVmNetworkArrayOutput values.
// You can construct a concrete instance of `GetXoaVmsVmNetworkArrayInput` via:
//
//	GetXoaVmsVmNetworkArray{ GetXoaVmsVmNetworkArgs{...} }
type GetXoaVmsVmNetworkArrayInput interface {
	pulumi.Input

	ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput
	ToGetXoaVmsVmNetworkArrayOutputWithContext(context.Context) GetXoaVmsVmNetworkArrayOutput
}

type GetXoaVmsVmNetworkArray []GetXoaVmsVmNetworkInput

func (GetXoaVmsVmNetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmNetwork)(nil)).Elem()
}

func (i GetXoaVmsVmNetworkArray) ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput {
	return i.ToGetXoaVmsVmNetworkArrayOutputWithContext(context.Background())
}

func (i GetXoaVmsVmNetworkArray) ToGetXoaVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetXoaVmsVmNetworkArrayOutput)
}

type GetXoaVmsVmNetworkOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmNetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetXoaVmsVmNetwork)(nil)).Elem()
}

func (o GetXoaVmsVmNetworkOutput) ToGetXoaVmsVmNetworkOutput() GetXoaVmsVmNetworkOutput {
	return o
}

func (o GetXoaVmsVmNetworkOutput) ToGetXoaVmsVmNetworkOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkOutput {
	return o
}

// Whether the device should be attached to the VM.
func (o GetXoaVmsVmNetworkOutput) Attached() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) *bool { return v.Attached }).(pulumi.BoolPtrOutput)
}

func (o GetXoaVmsVmNetworkOutput) Device() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.Device }).(pulumi.StringOutput)
}

// Determines the IP CIDR range the provider will wait for on this network interface. Resource creation is not complete until an IP address within the specified range becomes available. This parameter replaces the former `waitForIp` functionality. This only works if guest-tools are installed in the VM. Defaults to "", which skips IP address matching.
func (o GetXoaVmsVmNetworkOutput) ExpectedIpCidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) *string { return v.ExpectedIpCidr }).(pulumi.StringPtrOutput)
}

func (o GetXoaVmsVmNetworkOutput) Ipv4Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) []string { return v.Ipv4Addresses }).(pulumi.StringArrayOutput)
}

func (o GetXoaVmsVmNetworkOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) []string { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o GetXoaVmsVmNetworkOutput) MacAddress() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.MacAddress }).(pulumi.StringOutput)
}

// The ID of the network the VM will be on.
func (o GetXoaVmsVmNetworkOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v GetXoaVmsVmNetwork) string { return v.NetworkId }).(pulumi.StringOutput)
}

type GetXoaVmsVmNetworkArrayOutput struct{ *pulumi.OutputState }

func (GetXoaVmsVmNetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetXoaVmsVmNetwork)(nil)).Elem()
}

func (o GetXoaVmsVmNetworkArrayOutput) ToGetXoaVmsVmNetworkArrayOutput() GetXoaVmsVmNetworkArrayOutput {
	return o
}

func (o GetXoaVmsVmNetworkArrayOutput) ToGetXoaVmsVmNetworkArrayOutputWithContext(ctx context.Context) GetXoaVmsVmNetworkArrayOutput {
	return o
}

func (o GetXoaVmsVmNetworkArrayOutput) Index(i pulumi.IntInput) GetXoaVmsVmNetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetXoaVmsVmNetwork {
		return vs[0].([]GetXoaVmsVmNetwork)[vs[1].(int)]
	}).(GetXoaVmsVmNetworkOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSetLimitInput)(nil)).Elem(), ResourceSetLimitArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceSetLimitArrayInput)(nil)).Elem(), ResourceSetLimitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmCdromInput)(nil)).Elem(), VmCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmCdromPtrInput)(nil)).Elem(), VmCdromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmDiskInput)(nil)).Elem(), VmDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmDiskArrayInput)(nil)).Elem(), VmDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmNetworkInput)(nil)).Elem(), VmNetworkArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmNetworkArrayInput)(nil)).Elem(), VmNetworkArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaHostsHostInput)(nil)).Elem(), GetXoaHostsHostArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaHostsHostArrayInput)(nil)).Elem(), GetXoaHostsHostArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmInput)(nil)).Elem(), GetXoaVmsVmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmArrayInput)(nil)).Elem(), GetXoaVmsVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmDiskInput)(nil)).Elem(), GetXoaVmsVmDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmDiskArrayInput)(nil)).Elem(), GetXoaVmsVmDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmNetworkInput)(nil)).Elem(), GetXoaVmsVmNetworkArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetXoaVmsVmNetworkArrayInput)(nil)).Elem(), GetXoaVmsVmNetworkArray{})
	pulumi.RegisterOutputType(ResourceSetLimitOutput{})
	pulumi.RegisterOutputType(ResourceSetLimitArrayOutput{})
	pulumi.RegisterOutputType(VmCdromOutput{})
	pulumi.RegisterOutputType(VmCdromPtrOutput{})
	pulumi.RegisterOutputType(VmDiskOutput{})
	pulumi.RegisterOutputType(VmDiskArrayOutput{})
	pulumi.RegisterOutputType(VmNetworkOutput{})
	pulumi.RegisterOutputType(VmNetworkArrayOutput{})
	pulumi.RegisterOutputType(GetXoaHostsHostOutput{})
	pulumi.RegisterOutputType(GetXoaHostsHostArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmDiskOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmDiskArrayOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmNetworkOutput{})
	pulumi.RegisterOutputType(GetXoaVmsVmNetworkArrayOutput{})
}
