// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Xenorchestra
{
    /// <summary>
    /// ## Example Usage
    /// </summary>
    [XenorchestraResourceType("xenorchestra:index/vm:Vm")]
    public partial class Vm : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        /// be rescheduled.
        /// </summary>
        [Output("affinityHost")]
        public Output<string?> AffinityHost { get; private set; } = null!;

        /// <summary>
        /// If the VM will automatically turn on. Defaults to `false`.
        /// </summary>
        [Output("autoPoweron")]
        public Output<bool?> AutoPoweron { get; private set; } = null!;

        /// <summary>
        /// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        /// hard_shutdown, pause, shutdown, suspend, destroy. See:
        /// https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
        /// </summary>
        [Output("blockedOperations")]
        public Output<ImmutableArray<string>> BlockedOperations { get; private set; } = null!;

        /// <summary>
        /// The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        /// from `xe template-list`) and install the OS from the following ISO.
        /// </summary>
        [Output("cdrom")]
        public Output<Outputs.VmCdrom?> Cdrom { get; private set; } = null!;

        /// <summary>
        /// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        /// perform a `full` clone, the VM template must not be a disk template.
        /// </summary>
        [Output("cloneType")]
        public Output<string?> CloneType { get; private set; } = null!;

        /// <summary>
        /// The content of the cloud-init config to use. See the cloud init docs for more
        /// [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        /// </summary>
        [Output("cloudConfig")]
        public Output<string?> CloudConfig { get; private set; } = null!;

        /// <summary>
        /// The content of the cloud-init network configuration for the VM (uses [version
        /// 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        /// </summary>
        [Output("cloudNetworkConfig")]
        public Output<string?> CloudNetworkConfig { get; private set; } = null!;

        [Output("coreOs")]
        public Output<bool?> CoreOs { get; private set; } = null!;

        [Output("cpuCap")]
        public Output<int?> CpuCap { get; private set; } = null!;

        [Output("cpuWeight")]
        public Output<int?> CpuWeight { get; private set; } = null!;

        /// <summary>
        /// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        /// greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        /// filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        /// to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        /// </summary>
        [Output("cpus")]
        public Output<int> Cpus { get; private set; } = null!;

        /// <summary>
        /// Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        /// power_state must be set to `Running`.
        /// </summary>
        [Output("destroyCloudConfigVdiAfterBoot")]
        public Output<bool?> DestroyCloudConfigVdiAfterBoot { get; private set; } = null!;

        /// <summary>
        /// The disk the VM will have access to.
        /// </summary>
        [Output("disks")]
        public Output<ImmutableArray<Outputs.VmDisk>> Disks { get; private set; } = null!;

        /// <summary>
        /// Boolean parameter that allows a VM to use nested virtualization.
        /// </summary>
        [Output("expNestedHvm")]
        public Output<bool?> ExpNestedHvm { get; private set; } = null!;

        /// <summary>
        /// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        /// Defaults to empty string
        /// </summary>
        [Output("highAvailability")]
        public Output<string?> HighAvailability { get; private set; } = null!;

        [Output("host")]
        public Output<string?> Host { get; private set; } = null!;

        /// <summary>
        /// The firmware to use for the VM. Possible values are `bios` and `uefi`.
        /// </summary>
        [Output("hvmBootFirmware")]
        public Output<string?> HvmBootFirmware { get; private set; } = null!;

        /// <summary>
        /// This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        /// </summary>
        [Output("installationMethod")]
        public Output<string?> InstallationMethod { get; private set; } = null!;

        [Output("ipv4Addresses")]
        public Output<ImmutableArray<string>> Ipv4Addresses { get; private set; } = null!;

        /// <summary>
        /// This is only accessible if guest-tools is installed in the VM. While the output contains a list of ipv6 addresses, the
        /// presence of an IP address is only guaranteed if `expected_ip_cidr` is set for that interface. The list contains the ipv6
        /// addresses across all network interfaces in order.
        /// </summary>
        [Output("ipv6Addresses")]
        public Output<ImmutableArray<string>> Ipv6Addresses { get; private set; } = null!;

        /// <summary>
        /// The amount of memory in bytes the VM will have.\n\n!!! WARNING: Updates to this field will cause the VM to stop and
        /// start, as it sets both dynamic and static maximums.
        /// </summary>
        [Output("memoryMax")]
        public Output<double> MemoryMax { get; private set; } = null!;

        /// <summary>
        /// The amount of memory in bytes the VM will have. Set this value equal to memory_max to have a static memory.
        /// </summary>
        [Output("memoryMin")]
        public Output<int> MemoryMin { get; private set; } = null!;

        /// <summary>
        /// The description of the VM.
        /// </summary>
        [Output("nameDescription")]
        public Output<string?> NameDescription { get; private set; } = null!;

        /// <summary>
        /// The name of the VM.
        /// </summary>
        [Output("nameLabel")]
        public Output<string> NameLabel { get; private set; } = null!;

        /// <summary>
        /// The network for the VM.
        /// </summary>
        [Output("networks")]
        public Output<ImmutableArray<Outputs.VmNetwork>> Networks { get; private set; } = null!;

        /// <summary>
        /// The power state of the VM. This can be Running, Halted, Paused or Suspended.
        /// </summary>
        [Output("powerState")]
        public Output<string?> PowerState { get; private set; } = null!;

        [Output("resourceSet")]
        public Output<string?> ResourceSet { get; private set; } = null!;

        /// <summary>
        /// Number of seconds the VM should be delayed from starting.
        /// </summary>
        [Output("startDelay")]
        public Output<int?> StartDelay { get; private set; } = null!;

        /// <summary>
        /// The tags (labels) applied to the given entity.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The ID of the VM template to create the new VM from.
        /// </summary>
        [Output("template")]
        public Output<string> Template { get; private set; } = null!;

        /// <summary>
        /// The video adapter the VM should use. Possible values include std and cirrus.
        /// </summary>
        [Output("vga")]
        public Output<string?> Vga { get; private set; } = null!;

        /// <summary>
        /// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        /// </summary>
        [Output("videoram")]
        public Output<int?> Videoram { get; private set; } = null!;

        /// <summary>
        /// The key value pairs to be populated in xenstore.
        /// </summary>
        [Output("xenstore")]
        public Output<ImmutableDictionary<string, string>?> Xenstore { get; private set; } = null!;


        /// <summary>
        /// Create a Vm resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Vm(string name, VmArgs args, CustomResourceOptions? options = null)
            : base("xenorchestra:index/vm:Vm", name, args ?? new VmArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Vm(string name, Input<string> id, VmState? state = null, CustomResourceOptions? options = null)
            : base("xenorchestra:index/vm:Vm", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/vatesfr/pulumi-xenorchestra",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Vm resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Vm Get(string name, Input<string> id, VmState? state = null, CustomResourceOptions? options = null)
        {
            return new Vm(name, id, state, options);
        }
    }

    public sealed class VmArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        /// be rescheduled.
        /// </summary>
        [Input("affinityHost")]
        public Input<string>? AffinityHost { get; set; }

        /// <summary>
        /// If the VM will automatically turn on. Defaults to `false`.
        /// </summary>
        [Input("autoPoweron")]
        public Input<bool>? AutoPoweron { get; set; }

        [Input("blockedOperations")]
        private InputList<string>? _blockedOperations;

        /// <summary>
        /// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        /// hard_shutdown, pause, shutdown, suspend, destroy. See:
        /// https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
        /// </summary>
        public InputList<string> BlockedOperations
        {
            get => _blockedOperations ?? (_blockedOperations = new InputList<string>());
            set => _blockedOperations = value;
        }

        /// <summary>
        /// The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        /// from `xe template-list`) and install the OS from the following ISO.
        /// </summary>
        [Input("cdrom")]
        public Input<Inputs.VmCdromArgs>? Cdrom { get; set; }

        /// <summary>
        /// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        /// perform a `full` clone, the VM template must not be a disk template.
        /// </summary>
        [Input("cloneType")]
        public Input<string>? CloneType { get; set; }

        /// <summary>
        /// The content of the cloud-init config to use. See the cloud init docs for more
        /// [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        /// </summary>
        [Input("cloudConfig")]
        public Input<string>? CloudConfig { get; set; }

        /// <summary>
        /// The content of the cloud-init network configuration for the VM (uses [version
        /// 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        /// </summary>
        [Input("cloudNetworkConfig")]
        public Input<string>? CloudNetworkConfig { get; set; }

        [Input("coreOs")]
        public Input<bool>? CoreOs { get; set; }

        [Input("cpuCap")]
        public Input<int>? CpuCap { get; set; }

        [Input("cpuWeight")]
        public Input<int>? CpuWeight { get; set; }

        /// <summary>
        /// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        /// greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        /// filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        /// to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        /// </summary>
        [Input("cpus", required: true)]
        public Input<int> Cpus { get; set; } = null!;

        /// <summary>
        /// Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        /// power_state must be set to `Running`.
        /// </summary>
        [Input("destroyCloudConfigVdiAfterBoot")]
        public Input<bool>? DestroyCloudConfigVdiAfterBoot { get; set; }

        [Input("disks", required: true)]
        private InputList<Inputs.VmDiskArgs>? _disks;

        /// <summary>
        /// The disk the VM will have access to.
        /// </summary>
        public InputList<Inputs.VmDiskArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VmDiskArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// Boolean parameter that allows a VM to use nested virtualization.
        /// </summary>
        [Input("expNestedHvm")]
        public Input<bool>? ExpNestedHvm { get; set; }

        /// <summary>
        /// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        /// Defaults to empty string
        /// </summary>
        [Input("highAvailability")]
        public Input<string>? HighAvailability { get; set; }

        [Input("host")]
        public Input<string>? Host { get; set; }

        /// <summary>
        /// The firmware to use for the VM. Possible values are `bios` and `uefi`.
        /// </summary>
        [Input("hvmBootFirmware")]
        public Input<string>? HvmBootFirmware { get; set; }

        /// <summary>
        /// This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        /// </summary>
        [Input("installationMethod")]
        public Input<string>? InstallationMethod { get; set; }

        /// <summary>
        /// The amount of memory in bytes the VM will have.\n\n!!! WARNING: Updates to this field will cause the VM to stop and
        /// start, as it sets both dynamic and static maximums.
        /// </summary>
        [Input("memoryMax", required: true)]
        public Input<double> MemoryMax { get; set; } = null!;

        /// <summary>
        /// The amount of memory in bytes the VM will have. Set this value equal to memory_max to have a static memory.
        /// </summary>
        [Input("memoryMin")]
        public Input<int>? MemoryMin { get; set; }

        /// <summary>
        /// The description of the VM.
        /// </summary>
        [Input("nameDescription")]
        public Input<string>? NameDescription { get; set; }

        /// <summary>
        /// The name of the VM.
        /// </summary>
        [Input("nameLabel", required: true)]
        public Input<string> NameLabel { get; set; } = null!;

        [Input("networks", required: true)]
        private InputList<Inputs.VmNetworkArgs>? _networks;

        /// <summary>
        /// The network for the VM.
        /// </summary>
        public InputList<Inputs.VmNetworkArgs> Networks
        {
            get => _networks ?? (_networks = new InputList<Inputs.VmNetworkArgs>());
            set => _networks = value;
        }

        /// <summary>
        /// The power state of the VM. This can be Running, Halted, Paused or Suspended.
        /// </summary>
        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        [Input("resourceSet")]
        public Input<string>? ResourceSet { get; set; }

        /// <summary>
        /// Number of seconds the VM should be delayed from starting.
        /// </summary>
        [Input("startDelay")]
        public Input<int>? StartDelay { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The tags (labels) applied to the given entity.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The ID of the VM template to create the new VM from.
        /// </summary>
        [Input("template", required: true)]
        public Input<string> Template { get; set; } = null!;

        /// <summary>
        /// The video adapter the VM should use. Possible values include std and cirrus.
        /// </summary>
        [Input("vga")]
        public Input<string>? Vga { get; set; }

        /// <summary>
        /// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        /// </summary>
        [Input("videoram")]
        public Input<int>? Videoram { get; set; }

        [Input("xenstore")]
        private InputMap<string>? _xenstore;

        /// <summary>
        /// The key value pairs to be populated in xenstore.
        /// </summary>
        public InputMap<string> Xenstore
        {
            get => _xenstore ?? (_xenstore = new InputMap<string>());
            set => _xenstore = value;
        }

        public VmArgs()
        {
        }
        public static new VmArgs Empty => new VmArgs();
    }

    public sealed class VmState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        /// be rescheduled.
        /// </summary>
        [Input("affinityHost")]
        public Input<string>? AffinityHost { get; set; }

        /// <summary>
        /// If the VM will automatically turn on. Defaults to `false`.
        /// </summary>
        [Input("autoPoweron")]
        public Input<bool>? AutoPoweron { get; set; }

        [Input("blockedOperations")]
        private InputList<string>? _blockedOperations;

        /// <summary>
        /// List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        /// hard_shutdown, pause, shutdown, suspend, destroy. See:
        /// https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations
        /// </summary>
        public InputList<string> BlockedOperations
        {
            get => _blockedOperations ?? (_blockedOperations = new InputList<string>());
            set => _blockedOperations = value;
        }

        /// <summary>
        /// The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        /// from `xe template-list`) and install the OS from the following ISO.
        /// </summary>
        [Input("cdrom")]
        public Input<Inputs.VmCdromGetArgs>? Cdrom { get; set; }

        /// <summary>
        /// The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        /// perform a `full` clone, the VM template must not be a disk template.
        /// </summary>
        [Input("cloneType")]
        public Input<string>? CloneType { get; set; }

        /// <summary>
        /// The content of the cloud-init config to use. See the cloud init docs for more
        /// [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        /// </summary>
        [Input("cloudConfig")]
        public Input<string>? CloudConfig { get; set; }

        /// <summary>
        /// The content of the cloud-init network configuration for the VM (uses [version
        /// 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        /// </summary>
        [Input("cloudNetworkConfig")]
        public Input<string>? CloudNetworkConfig { get; set; }

        [Input("coreOs")]
        public Input<bool>? CoreOs { get; set; }

        [Input("cpuCap")]
        public Input<int>? CpuCap { get; set; }

        [Input("cpuWeight")]
        public Input<int>? CpuWeight { get; set; }

        /// <summary>
        /// The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        /// greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        /// filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        /// to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        /// </summary>
        [Input("cpus")]
        public Input<int>? Cpus { get; set; }

        /// <summary>
        /// Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        /// power_state must be set to `Running`.
        /// </summary>
        [Input("destroyCloudConfigVdiAfterBoot")]
        public Input<bool>? DestroyCloudConfigVdiAfterBoot { get; set; }

        [Input("disks")]
        private InputList<Inputs.VmDiskGetArgs>? _disks;

        /// <summary>
        /// The disk the VM will have access to.
        /// </summary>
        public InputList<Inputs.VmDiskGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VmDiskGetArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// Boolean parameter that allows a VM to use nested virtualization.
        /// </summary>
        [Input("expNestedHvm")]
        public Input<bool>? ExpNestedHvm { get; set; }

        /// <summary>
        /// The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        /// Defaults to empty string
        /// </summary>
        [Input("highAvailability")]
        public Input<string>? HighAvailability { get; set; }

        [Input("host")]
        public Input<string>? Host { get; set; }

        /// <summary>
        /// The firmware to use for the VM. Possible values are `bios` and `uefi`.
        /// </summary>
        [Input("hvmBootFirmware")]
        public Input<string>? HvmBootFirmware { get; set; }

        /// <summary>
        /// This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        /// </summary>
        [Input("installationMethod")]
        public Input<string>? InstallationMethod { get; set; }

        [Input("ipv4Addresses")]
        private InputList<string>? _ipv4Addresses;
        public InputList<string> Ipv4Addresses
        {
            get => _ipv4Addresses ?? (_ipv4Addresses = new InputList<string>());
            set => _ipv4Addresses = value;
        }

        [Input("ipv6Addresses")]
        private InputList<string>? _ipv6Addresses;

        /// <summary>
        /// This is only accessible if guest-tools is installed in the VM. While the output contains a list of ipv6 addresses, the
        /// presence of an IP address is only guaranteed if `expected_ip_cidr` is set for that interface. The list contains the ipv6
        /// addresses across all network interfaces in order.
        /// </summary>
        public InputList<string> Ipv6Addresses
        {
            get => _ipv6Addresses ?? (_ipv6Addresses = new InputList<string>());
            set => _ipv6Addresses = value;
        }

        /// <summary>
        /// The amount of memory in bytes the VM will have.\n\n!!! WARNING: Updates to this field will cause the VM to stop and
        /// start, as it sets both dynamic and static maximums.
        /// </summary>
        [Input("memoryMax")]
        public Input<double>? MemoryMax { get; set; }

        /// <summary>
        /// The amount of memory in bytes the VM will have. Set this value equal to memory_max to have a static memory.
        /// </summary>
        [Input("memoryMin")]
        public Input<int>? MemoryMin { get; set; }

        /// <summary>
        /// The description of the VM.
        /// </summary>
        [Input("nameDescription")]
        public Input<string>? NameDescription { get; set; }

        /// <summary>
        /// The name of the VM.
        /// </summary>
        [Input("nameLabel")]
        public Input<string>? NameLabel { get; set; }

        [Input("networks")]
        private InputList<Inputs.VmNetworkGetArgs>? _networks;

        /// <summary>
        /// The network for the VM.
        /// </summary>
        public InputList<Inputs.VmNetworkGetArgs> Networks
        {
            get => _networks ?? (_networks = new InputList<Inputs.VmNetworkGetArgs>());
            set => _networks = value;
        }

        /// <summary>
        /// The power state of the VM. This can be Running, Halted, Paused or Suspended.
        /// </summary>
        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        [Input("resourceSet")]
        public Input<string>? ResourceSet { get; set; }

        /// <summary>
        /// Number of seconds the VM should be delayed from starting.
        /// </summary>
        [Input("startDelay")]
        public Input<int>? StartDelay { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The tags (labels) applied to the given entity.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The ID of the VM template to create the new VM from.
        /// </summary>
        [Input("template")]
        public Input<string>? Template { get; set; }

        /// <summary>
        /// The video adapter the VM should use. Possible values include std and cirrus.
        /// </summary>
        [Input("vga")]
        public Input<string>? Vga { get; set; }

        /// <summary>
        /// The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        /// </summary>
        [Input("videoram")]
        public Input<int>? Videoram { get; set; }

        [Input("xenstore")]
        private InputMap<string>? _xenstore;

        /// <summary>
        /// The key value pairs to be populated in xenstore.
        /// </summary>
        public InputMap<string> Xenstore
        {
            get => _xenstore ?? (_xenstore = new InputMap<string>());
            set => _xenstore = value;
        }

        public VmState()
        {
        }
        public static new VmState Empty => new VmState();
    }
}
