# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['VmArgs', 'Vm']

@pulumi.input_type
class VmArgs:
    def __init__(__self__, *,
                 cpus: pulumi.Input[int],
                 disks: pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]],
                 memory_max: pulumi.Input[int],
                 name_label: pulumi.Input[str],
                 networks: pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]],
                 template: pulumi.Input[str],
                 affinity_host: Optional[pulumi.Input[str]] = None,
                 auto_poweron: Optional[pulumi.Input[bool]] = None,
                 blocked_operations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cdrom: Optional[pulumi.Input['VmCdromArgs']] = None,
                 clone_type: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloud_network_config: Optional[pulumi.Input[str]] = None,
                 core_os: Optional[pulumi.Input[bool]] = None,
                 cpu_cap: Optional[pulumi.Input[int]] = None,
                 cpu_weight: Optional[pulumi.Input[int]] = None,
                 destroy_cloud_config_vdi_after_boot: Optional[pulumi.Input[bool]] = None,
                 exp_nested_hvm: Optional[pulumi.Input[bool]] = None,
                 high_availability: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 hvm_boot_firmware: Optional[pulumi.Input[str]] = None,
                 installation_method: Optional[pulumi.Input[str]] = None,
                 name_description: Optional[pulumi.Input[str]] = None,
                 power_state: Optional[pulumi.Input[str]] = None,
                 resource_set: Optional[pulumi.Input[str]] = None,
                 start_delay: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vga: Optional[pulumi.Input[str]] = None,
                 videoram: Optional[pulumi.Input[int]] = None,
                 xenstore: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a Vm resource.
        :param pulumi.Input[int] cpus: The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
               greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
               filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
               to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        :param pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]] disks: The disk the VM will have access to.
        :param pulumi.Input[int] memory_max: The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
               value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
               xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
               memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
               stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        :param pulumi.Input[str] name_label: The name of the VM.
        :param pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]] networks: The network for the VM.
        :param pulumi.Input[str] template: The ID of the VM template to create the new VM from.
        :param pulumi.Input[str] affinity_host: The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
               be rescheduled.
        :param pulumi.Input[bool] auto_poweron: If the VM will automatically turn on. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_operations: List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
               hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
               can be found here
        :param pulumi.Input['VmCdromArgs'] cdrom: The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
               from `xe template-list`) and install the OS from the following ISO.
        :param pulumi.Input[str] clone_type: The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
               perform a `full` clone, the VM template must not be a disk template.
        :param pulumi.Input[str] cloud_config: The content of the cloud-init config to use. See the cloud init docs for more
               [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        :param pulumi.Input[str] cloud_network_config: The content of the cloud-init network configuration for the VM (uses [version
               1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        :param pulumi.Input[bool] destroy_cloud_config_vdi_after_boot: Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
               power_state must be set to `Running`.
        :param pulumi.Input[bool] exp_nested_hvm: Boolean parameter that allows a VM to use nested virtualization.
        :param pulumi.Input[str] high_availability: The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
               Defaults to empty string
        :param pulumi.Input[str] hvm_boot_firmware: The firmware to use for the VM. Possible values are `bios` and `uefi`.
        :param pulumi.Input[str] installation_method: This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        :param pulumi.Input[str] name_description: The description of the VM.
        :param pulumi.Input[str] power_state: The power state of the VM. This can be Running, Halted, Paused or Suspended.
        :param pulumi.Input[int] start_delay: Number of seconds the VM should be delayed from starting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The tags (labels) applied to the given entity.
        :param pulumi.Input[str] vga: The video adapter the VM should use. Possible values include std and cirrus.
        :param pulumi.Input[int] videoram: The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] xenstore: The key value pairs to be populated in xenstore.
        """
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "disks", disks)
        pulumi.set(__self__, "memory_max", memory_max)
        pulumi.set(__self__, "name_label", name_label)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "template", template)
        if affinity_host is not None:
            pulumi.set(__self__, "affinity_host", affinity_host)
        if auto_poweron is not None:
            pulumi.set(__self__, "auto_poweron", auto_poweron)
        if blocked_operations is not None:
            pulumi.set(__self__, "blocked_operations", blocked_operations)
        if cdrom is not None:
            pulumi.set(__self__, "cdrom", cdrom)
        if clone_type is not None:
            pulumi.set(__self__, "clone_type", clone_type)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloud_network_config is not None:
            pulumi.set(__self__, "cloud_network_config", cloud_network_config)
        if core_os is not None:
            pulumi.set(__self__, "core_os", core_os)
        if cpu_cap is not None:
            pulumi.set(__self__, "cpu_cap", cpu_cap)
        if cpu_weight is not None:
            pulumi.set(__self__, "cpu_weight", cpu_weight)
        if destroy_cloud_config_vdi_after_boot is not None:
            pulumi.set(__self__, "destroy_cloud_config_vdi_after_boot", destroy_cloud_config_vdi_after_boot)
        if exp_nested_hvm is not None:
            pulumi.set(__self__, "exp_nested_hvm", exp_nested_hvm)
        if high_availability is not None:
            pulumi.set(__self__, "high_availability", high_availability)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hvm_boot_firmware is not None:
            pulumi.set(__self__, "hvm_boot_firmware", hvm_boot_firmware)
        if installation_method is not None:
            pulumi.set(__self__, "installation_method", installation_method)
        if name_description is not None:
            pulumi.set(__self__, "name_description", name_description)
        if power_state is not None:
            pulumi.set(__self__, "power_state", power_state)
        if resource_set is not None:
            pulumi.set(__self__, "resource_set", resource_set)
        if start_delay is not None:
            pulumi.set(__self__, "start_delay", start_delay)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vga is not None:
            pulumi.set(__self__, "vga", vga)
        if videoram is not None:
            pulumi.set(__self__, "videoram", videoram)
        if xenstore is not None:
            pulumi.set(__self__, "xenstore", xenstore)

    @property
    @pulumi.getter
    def cpus(self) -> pulumi.Input[int]:
        """
        The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: pulumi.Input[int]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter
    def disks(self) -> pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]]:
        """
        The disk the VM will have access to.
        """
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]]):
        pulumi.set(self, "disks", value)

    @property
    @pulumi.getter(name="memoryMax")
    def memory_max(self) -> pulumi.Input[int]:
        """
        The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
        value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
        xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
        memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
        stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        """
        return pulumi.get(self, "memory_max")

    @memory_max.setter
    def memory_max(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory_max", value)

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> pulumi.Input[str]:
        """
        The name of the VM.
        """
        return pulumi.get(self, "name_label")

    @name_label.setter
    def name_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "name_label", value)

    @property
    @pulumi.getter
    def networks(self) -> pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]]:
        """
        The network for the VM.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[str]:
        """
        The ID of the VM template to create the new VM from.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="affinityHost")
    def affinity_host(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        be rescheduled.
        """
        return pulumi.get(self, "affinity_host")

    @affinity_host.setter
    def affinity_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity_host", value)

    @property
    @pulumi.getter(name="autoPoweron")
    def auto_poweron(self) -> Optional[pulumi.Input[bool]]:
        """
        If the VM will automatically turn on. Defaults to `false`.
        """
        return pulumi.get(self, "auto_poweron")

    @auto_poweron.setter
    def auto_poweron(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_poweron", value)

    @property
    @pulumi.getter(name="blockedOperations")
    def blocked_operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
        can be found here
        """
        return pulumi.get(self, "blocked_operations")

    @blocked_operations.setter
    def blocked_operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocked_operations", value)

    @property
    @pulumi.getter
    def cdrom(self) -> Optional[pulumi.Input['VmCdromArgs']]:
        """
        The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        from `xe template-list`) and install the OS from the following ISO.
        """
        return pulumi.get(self, "cdrom")

    @cdrom.setter
    def cdrom(self, value: Optional[pulumi.Input['VmCdromArgs']]):
        pulumi.set(self, "cdrom", value)

    @property
    @pulumi.getter(name="cloneType")
    def clone_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        perform a `full` clone, the VM template must not be a disk template.
        """
        return pulumi.get(self, "clone_type")

    @clone_type.setter
    def clone_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clone_type", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input[str]]:
        """
        The content of the cloud-init config to use. See the cloud init docs for more
        [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter(name="cloudNetworkConfig")
    def cloud_network_config(self) -> Optional[pulumi.Input[str]]:
        """
        The content of the cloud-init network configuration for the VM (uses [version
        1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        """
        return pulumi.get(self, "cloud_network_config")

    @cloud_network_config.setter
    def cloud_network_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_network_config", value)

    @property
    @pulumi.getter(name="coreOs")
    def core_os(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "core_os")

    @core_os.setter
    def core_os(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "core_os", value)

    @property
    @pulumi.getter(name="cpuCap")
    def cpu_cap(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_cap")

    @cpu_cap.setter
    def cpu_cap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_cap", value)

    @property
    @pulumi.getter(name="cpuWeight")
    def cpu_weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_weight")

    @cpu_weight.setter
    def cpu_weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_weight", value)

    @property
    @pulumi.getter(name="destroyCloudConfigVdiAfterBoot")
    def destroy_cloud_config_vdi_after_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        power_state must be set to `Running`.
        """
        return pulumi.get(self, "destroy_cloud_config_vdi_after_boot")

    @destroy_cloud_config_vdi_after_boot.setter
    def destroy_cloud_config_vdi_after_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "destroy_cloud_config_vdi_after_boot", value)

    @property
    @pulumi.getter(name="expNestedHvm")
    def exp_nested_hvm(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean parameter that allows a VM to use nested virtualization.
        """
        return pulumi.get(self, "exp_nested_hvm")

    @exp_nested_hvm.setter
    def exp_nested_hvm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exp_nested_hvm", value)

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> Optional[pulumi.Input[str]]:
        """
        The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        Defaults to empty string
        """
        return pulumi.get(self, "high_availability")

    @high_availability.setter
    def high_availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_availability", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="hvmBootFirmware")
    def hvm_boot_firmware(self) -> Optional[pulumi.Input[str]]:
        """
        The firmware to use for the VM. Possible values are `bios` and `uefi`.
        """
        return pulumi.get(self, "hvm_boot_firmware")

    @hvm_boot_firmware.setter
    def hvm_boot_firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hvm_boot_firmware", value)

    @property
    @pulumi.getter(name="installationMethod")
    def installation_method(self) -> Optional[pulumi.Input[str]]:
        """
        This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        """
        return pulumi.get(self, "installation_method")

    @installation_method.setter
    def installation_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "installation_method", value)

    @property
    @pulumi.getter(name="nameDescription")
    def name_description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the VM.
        """
        return pulumi.get(self, "name_description")

    @name_description.setter
    def name_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_description", value)

    @property
    @pulumi.getter(name="powerState")
    def power_state(self) -> Optional[pulumi.Input[str]]:
        """
        The power state of the VM. This can be Running, Halted, Paused or Suspended.
        """
        return pulumi.get(self, "power_state")

    @power_state.setter
    def power_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_state", value)

    @property
    @pulumi.getter(name="resourceSet")
    def resource_set(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_set")

    @resource_set.setter
    def resource_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_set", value)

    @property
    @pulumi.getter(name="startDelay")
    def start_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds the VM should be delayed from starting.
        """
        return pulumi.get(self, "start_delay")

    @start_delay.setter
    def start_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_delay", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The tags (labels) applied to the given entity.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def vga(self) -> Optional[pulumi.Input[str]]:
        """
        The video adapter the VM should use. Possible values include std and cirrus.
        """
        return pulumi.get(self, "vga")

    @vga.setter
    def vga(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vga", value)

    @property
    @pulumi.getter
    def videoram(self) -> Optional[pulumi.Input[int]]:
        """
        The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        """
        return pulumi.get(self, "videoram")

    @videoram.setter
    def videoram(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "videoram", value)

    @property
    @pulumi.getter
    def xenstore(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The key value pairs to be populated in xenstore.
        """
        return pulumi.get(self, "xenstore")

    @xenstore.setter
    def xenstore(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "xenstore", value)


@pulumi.input_type
class _VmState:
    def __init__(__self__, *,
                 affinity_host: Optional[pulumi.Input[str]] = None,
                 auto_poweron: Optional[pulumi.Input[bool]] = None,
                 blocked_operations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cdrom: Optional[pulumi.Input['VmCdromArgs']] = None,
                 clone_type: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloud_network_config: Optional[pulumi.Input[str]] = None,
                 core_os: Optional[pulumi.Input[bool]] = None,
                 cpu_cap: Optional[pulumi.Input[int]] = None,
                 cpu_weight: Optional[pulumi.Input[int]] = None,
                 cpus: Optional[pulumi.Input[int]] = None,
                 destroy_cloud_config_vdi_after_boot: Optional[pulumi.Input[bool]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]]] = None,
                 exp_nested_hvm: Optional[pulumi.Input[bool]] = None,
                 high_availability: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 hvm_boot_firmware: Optional[pulumi.Input[str]] = None,
                 installation_method: Optional[pulumi.Input[str]] = None,
                 ipv4_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 memory_max: Optional[pulumi.Input[int]] = None,
                 name_description: Optional[pulumi.Input[str]] = None,
                 name_label: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]]] = None,
                 power_state: Optional[pulumi.Input[str]] = None,
                 resource_set: Optional[pulumi.Input[str]] = None,
                 start_delay: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 template: Optional[pulumi.Input[str]] = None,
                 vga: Optional[pulumi.Input[str]] = None,
                 videoram: Optional[pulumi.Input[int]] = None,
                 xenstore: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Input properties used for looking up and filtering Vm resources.
        :param pulumi.Input[str] affinity_host: The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
               be rescheduled.
        :param pulumi.Input[bool] auto_poweron: If the VM will automatically turn on. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_operations: List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
               hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
               can be found here
        :param pulumi.Input['VmCdromArgs'] cdrom: The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
               from `xe template-list`) and install the OS from the following ISO.
        :param pulumi.Input[str] clone_type: The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
               perform a `full` clone, the VM template must not be a disk template.
        :param pulumi.Input[str] cloud_config: The content of the cloud-init config to use. See the cloud init docs for more
               [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        :param pulumi.Input[str] cloud_network_config: The content of the cloud-init network configuration for the VM (uses [version
               1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        :param pulumi.Input[int] cpus: The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
               greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
               filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
               to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        :param pulumi.Input[bool] destroy_cloud_config_vdi_after_boot: Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
               power_state must be set to `Running`.
        :param pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]] disks: The disk the VM will have access to.
        :param pulumi.Input[bool] exp_nested_hvm: Boolean parameter that allows a VM to use nested virtualization.
        :param pulumi.Input[str] high_availability: The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
               Defaults to empty string
        :param pulumi.Input[str] hvm_boot_firmware: The firmware to use for the VM. Possible values are `bios` and `uefi`.
        :param pulumi.Input[str] installation_method: This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_addresses: This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network
               interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
        :param pulumi.Input[int] memory_max: The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
               value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
               xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
               memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
               stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        :param pulumi.Input[str] name_description: The description of the VM.
        :param pulumi.Input[str] name_label: The name of the VM.
        :param pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]] networks: The network for the VM.
        :param pulumi.Input[str] power_state: The power state of the VM. This can be Running, Halted, Paused or Suspended.
        :param pulumi.Input[int] start_delay: Number of seconds the VM should be delayed from starting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The tags (labels) applied to the given entity.
        :param pulumi.Input[str] template: The ID of the VM template to create the new VM from.
        :param pulumi.Input[str] vga: The video adapter the VM should use. Possible values include std and cirrus.
        :param pulumi.Input[int] videoram: The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] xenstore: The key value pairs to be populated in xenstore.
        """
        if affinity_host is not None:
            pulumi.set(__self__, "affinity_host", affinity_host)
        if auto_poweron is not None:
            pulumi.set(__self__, "auto_poweron", auto_poweron)
        if blocked_operations is not None:
            pulumi.set(__self__, "blocked_operations", blocked_operations)
        if cdrom is not None:
            pulumi.set(__self__, "cdrom", cdrom)
        if clone_type is not None:
            pulumi.set(__self__, "clone_type", clone_type)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloud_network_config is not None:
            pulumi.set(__self__, "cloud_network_config", cloud_network_config)
        if core_os is not None:
            pulumi.set(__self__, "core_os", core_os)
        if cpu_cap is not None:
            pulumi.set(__self__, "cpu_cap", cpu_cap)
        if cpu_weight is not None:
            pulumi.set(__self__, "cpu_weight", cpu_weight)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if destroy_cloud_config_vdi_after_boot is not None:
            pulumi.set(__self__, "destroy_cloud_config_vdi_after_boot", destroy_cloud_config_vdi_after_boot)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if exp_nested_hvm is not None:
            pulumi.set(__self__, "exp_nested_hvm", exp_nested_hvm)
        if high_availability is not None:
            pulumi.set(__self__, "high_availability", high_availability)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hvm_boot_firmware is not None:
            pulumi.set(__self__, "hvm_boot_firmware", hvm_boot_firmware)
        if installation_method is not None:
            pulumi.set(__self__, "installation_method", installation_method)
        if ipv4_addresses is not None:
            pulumi.set(__self__, "ipv4_addresses", ipv4_addresses)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if memory_max is not None:
            pulumi.set(__self__, "memory_max", memory_max)
        if name_description is not None:
            pulumi.set(__self__, "name_description", name_description)
        if name_label is not None:
            pulumi.set(__self__, "name_label", name_label)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if power_state is not None:
            pulumi.set(__self__, "power_state", power_state)
        if resource_set is not None:
            pulumi.set(__self__, "resource_set", resource_set)
        if start_delay is not None:
            pulumi.set(__self__, "start_delay", start_delay)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if vga is not None:
            pulumi.set(__self__, "vga", vga)
        if videoram is not None:
            pulumi.set(__self__, "videoram", videoram)
        if xenstore is not None:
            pulumi.set(__self__, "xenstore", xenstore)

    @property
    @pulumi.getter(name="affinityHost")
    def affinity_host(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        be rescheduled.
        """
        return pulumi.get(self, "affinity_host")

    @affinity_host.setter
    def affinity_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity_host", value)

    @property
    @pulumi.getter(name="autoPoweron")
    def auto_poweron(self) -> Optional[pulumi.Input[bool]]:
        """
        If the VM will automatically turn on. Defaults to `false`.
        """
        return pulumi.get(self, "auto_poweron")

    @auto_poweron.setter
    def auto_poweron(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_poweron", value)

    @property
    @pulumi.getter(name="blockedOperations")
    def blocked_operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
        can be found here
        """
        return pulumi.get(self, "blocked_operations")

    @blocked_operations.setter
    def blocked_operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocked_operations", value)

    @property
    @pulumi.getter
    def cdrom(self) -> Optional[pulumi.Input['VmCdromArgs']]:
        """
        The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        from `xe template-list`) and install the OS from the following ISO.
        """
        return pulumi.get(self, "cdrom")

    @cdrom.setter
    def cdrom(self, value: Optional[pulumi.Input['VmCdromArgs']]):
        pulumi.set(self, "cdrom", value)

    @property
    @pulumi.getter(name="cloneType")
    def clone_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        perform a `full` clone, the VM template must not be a disk template.
        """
        return pulumi.get(self, "clone_type")

    @clone_type.setter
    def clone_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clone_type", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input[str]]:
        """
        The content of the cloud-init config to use. See the cloud init docs for more
        [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter(name="cloudNetworkConfig")
    def cloud_network_config(self) -> Optional[pulumi.Input[str]]:
        """
        The content of the cloud-init network configuration for the VM (uses [version
        1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        """
        return pulumi.get(self, "cloud_network_config")

    @cloud_network_config.setter
    def cloud_network_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_network_config", value)

    @property
    @pulumi.getter(name="coreOs")
    def core_os(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "core_os")

    @core_os.setter
    def core_os(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "core_os", value)

    @property
    @pulumi.getter(name="cpuCap")
    def cpu_cap(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_cap")

    @cpu_cap.setter
    def cpu_cap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_cap", value)

    @property
    @pulumi.getter(name="cpuWeight")
    def cpu_weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_weight")

    @cpu_weight.setter
    def cpu_weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_weight", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter(name="destroyCloudConfigVdiAfterBoot")
    def destroy_cloud_config_vdi_after_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        power_state must be set to `Running`.
        """
        return pulumi.get(self, "destroy_cloud_config_vdi_after_boot")

    @destroy_cloud_config_vdi_after_boot.setter
    def destroy_cloud_config_vdi_after_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "destroy_cloud_config_vdi_after_boot", value)

    @property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]]]:
        """
        The disk the VM will have access to.
        """
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @property
    @pulumi.getter(name="expNestedHvm")
    def exp_nested_hvm(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean parameter that allows a VM to use nested virtualization.
        """
        return pulumi.get(self, "exp_nested_hvm")

    @exp_nested_hvm.setter
    def exp_nested_hvm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exp_nested_hvm", value)

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> Optional[pulumi.Input[str]]:
        """
        The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        Defaults to empty string
        """
        return pulumi.get(self, "high_availability")

    @high_availability.setter
    def high_availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high_availability", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="hvmBootFirmware")
    def hvm_boot_firmware(self) -> Optional[pulumi.Input[str]]:
        """
        The firmware to use for the VM. Possible values are `bios` and `uefi`.
        """
        return pulumi.get(self, "hvm_boot_firmware")

    @hvm_boot_firmware.setter
    def hvm_boot_firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hvm_boot_firmware", value)

    @property
    @pulumi.getter(name="installationMethod")
    def installation_method(self) -> Optional[pulumi.Input[str]]:
        """
        This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        """
        return pulumi.get(self, "installation_method")

    @installation_method.setter
    def installation_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "installation_method", value)

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ipv4_addresses")

    @ipv4_addresses.setter
    def ipv4_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv4_addresses", value)

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network
        interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ipv6_addresses", value)

    @property
    @pulumi.getter(name="memoryMax")
    def memory_max(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
        value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
        xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
        memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
        stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        """
        return pulumi.get(self, "memory_max")

    @memory_max.setter
    def memory_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_max", value)

    @property
    @pulumi.getter(name="nameDescription")
    def name_description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the VM.
        """
        return pulumi.get(self, "name_description")

    @name_description.setter
    def name_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_description", value)

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the VM.
        """
        return pulumi.get(self, "name_label")

    @name_label.setter
    def name_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_label", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]]]:
        """
        The network for the VM.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="powerState")
    def power_state(self) -> Optional[pulumi.Input[str]]:
        """
        The power state of the VM. This can be Running, Halted, Paused or Suspended.
        """
        return pulumi.get(self, "power_state")

    @power_state.setter
    def power_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_state", value)

    @property
    @pulumi.getter(name="resourceSet")
    def resource_set(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_set")

    @resource_set.setter
    def resource_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_set", value)

    @property
    @pulumi.getter(name="startDelay")
    def start_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds the VM should be delayed from starting.
        """
        return pulumi.get(self, "start_delay")

    @start_delay.setter
    def start_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_delay", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The tags (labels) applied to the given entity.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the VM template to create the new VM from.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def vga(self) -> Optional[pulumi.Input[str]]:
        """
        The video adapter the VM should use. Possible values include std and cirrus.
        """
        return pulumi.get(self, "vga")

    @vga.setter
    def vga(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vga", value)

    @property
    @pulumi.getter
    def videoram(self) -> Optional[pulumi.Input[int]]:
        """
        The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        """
        return pulumi.get(self, "videoram")

    @videoram.setter
    def videoram(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "videoram", value)

    @property
    @pulumi.getter
    def xenstore(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The key value pairs to be populated in xenstore.
        """
        return pulumi.get(self, "xenstore")

    @xenstore.setter
    def xenstore(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "xenstore", value)


class Vm(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 affinity_host: Optional[pulumi.Input[str]] = None,
                 auto_poweron: Optional[pulumi.Input[bool]] = None,
                 blocked_operations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cdrom: Optional[pulumi.Input[Union['VmCdromArgs', 'VmCdromArgsDict']]] = None,
                 clone_type: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloud_network_config: Optional[pulumi.Input[str]] = None,
                 core_os: Optional[pulumi.Input[bool]] = None,
                 cpu_cap: Optional[pulumi.Input[int]] = None,
                 cpu_weight: Optional[pulumi.Input[int]] = None,
                 cpus: Optional[pulumi.Input[int]] = None,
                 destroy_cloud_config_vdi_after_boot: Optional[pulumi.Input[bool]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmDiskArgs', 'VmDiskArgsDict']]]]] = None,
                 exp_nested_hvm: Optional[pulumi.Input[bool]] = None,
                 high_availability: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 hvm_boot_firmware: Optional[pulumi.Input[str]] = None,
                 installation_method: Optional[pulumi.Input[str]] = None,
                 memory_max: Optional[pulumi.Input[int]] = None,
                 name_description: Optional[pulumi.Input[str]] = None,
                 name_label: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmNetworkArgs', 'VmNetworkArgsDict']]]]] = None,
                 power_state: Optional[pulumi.Input[str]] = None,
                 resource_set: Optional[pulumi.Input[str]] = None,
                 start_delay: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 template: Optional[pulumi.Input[str]] = None,
                 vga: Optional[pulumi.Input[str]] = None,
                 videoram: Optional[pulumi.Input[int]] = None,
                 xenstore: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        ## Example Usage

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] affinity_host: The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
               be rescheduled.
        :param pulumi.Input[bool] auto_poweron: If the VM will automatically turn on. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_operations: List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
               hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
               can be found here
        :param pulumi.Input[Union['VmCdromArgs', 'VmCdromArgsDict']] cdrom: The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
               from `xe template-list`) and install the OS from the following ISO.
        :param pulumi.Input[str] clone_type: The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
               perform a `full` clone, the VM template must not be a disk template.
        :param pulumi.Input[str] cloud_config: The content of the cloud-init config to use. See the cloud init docs for more
               [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        :param pulumi.Input[str] cloud_network_config: The content of the cloud-init network configuration for the VM (uses [version
               1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        :param pulumi.Input[int] cpus: The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
               greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
               filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
               to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        :param pulumi.Input[bool] destroy_cloud_config_vdi_after_boot: Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
               power_state must be set to `Running`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['VmDiskArgs', 'VmDiskArgsDict']]]] disks: The disk the VM will have access to.
        :param pulumi.Input[bool] exp_nested_hvm: Boolean parameter that allows a VM to use nested virtualization.
        :param pulumi.Input[str] high_availability: The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
               Defaults to empty string
        :param pulumi.Input[str] hvm_boot_firmware: The firmware to use for the VM. Possible values are `bios` and `uefi`.
        :param pulumi.Input[str] installation_method: This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        :param pulumi.Input[int] memory_max: The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
               value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
               xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
               memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
               stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        :param pulumi.Input[str] name_description: The description of the VM.
        :param pulumi.Input[str] name_label: The name of the VM.
        :param pulumi.Input[Sequence[pulumi.Input[Union['VmNetworkArgs', 'VmNetworkArgsDict']]]] networks: The network for the VM.
        :param pulumi.Input[str] power_state: The power state of the VM. This can be Running, Halted, Paused or Suspended.
        :param pulumi.Input[int] start_delay: Number of seconds the VM should be delayed from starting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The tags (labels) applied to the given entity.
        :param pulumi.Input[str] template: The ID of the VM template to create the new VM from.
        :param pulumi.Input[str] vga: The video adapter the VM should use. Possible values include std and cirrus.
        :param pulumi.Input[int] videoram: The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] xenstore: The key value pairs to be populated in xenstore.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: VmArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        :param str resource_name: The name of the resource.
        :param VmArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(VmArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 affinity_host: Optional[pulumi.Input[str]] = None,
                 auto_poweron: Optional[pulumi.Input[bool]] = None,
                 blocked_operations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cdrom: Optional[pulumi.Input[Union['VmCdromArgs', 'VmCdromArgsDict']]] = None,
                 clone_type: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloud_network_config: Optional[pulumi.Input[str]] = None,
                 core_os: Optional[pulumi.Input[bool]] = None,
                 cpu_cap: Optional[pulumi.Input[int]] = None,
                 cpu_weight: Optional[pulumi.Input[int]] = None,
                 cpus: Optional[pulumi.Input[int]] = None,
                 destroy_cloud_config_vdi_after_boot: Optional[pulumi.Input[bool]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmDiskArgs', 'VmDiskArgsDict']]]]] = None,
                 exp_nested_hvm: Optional[pulumi.Input[bool]] = None,
                 high_availability: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 hvm_boot_firmware: Optional[pulumi.Input[str]] = None,
                 installation_method: Optional[pulumi.Input[str]] = None,
                 memory_max: Optional[pulumi.Input[int]] = None,
                 name_description: Optional[pulumi.Input[str]] = None,
                 name_label: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmNetworkArgs', 'VmNetworkArgsDict']]]]] = None,
                 power_state: Optional[pulumi.Input[str]] = None,
                 resource_set: Optional[pulumi.Input[str]] = None,
                 start_delay: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 template: Optional[pulumi.Input[str]] = None,
                 vga: Optional[pulumi.Input[str]] = None,
                 videoram: Optional[pulumi.Input[int]] = None,
                 xenstore: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = VmArgs.__new__(VmArgs)

            __props__.__dict__["affinity_host"] = affinity_host
            __props__.__dict__["auto_poweron"] = auto_poweron
            __props__.__dict__["blocked_operations"] = blocked_operations
            __props__.__dict__["cdrom"] = cdrom
            __props__.__dict__["clone_type"] = clone_type
            __props__.__dict__["cloud_config"] = cloud_config
            __props__.__dict__["cloud_network_config"] = cloud_network_config
            __props__.__dict__["core_os"] = core_os
            __props__.__dict__["cpu_cap"] = cpu_cap
            __props__.__dict__["cpu_weight"] = cpu_weight
            if cpus is None and not opts.urn:
                raise TypeError("Missing required property 'cpus'")
            __props__.__dict__["cpus"] = cpus
            __props__.__dict__["destroy_cloud_config_vdi_after_boot"] = destroy_cloud_config_vdi_after_boot
            if disks is None and not opts.urn:
                raise TypeError("Missing required property 'disks'")
            __props__.__dict__["disks"] = disks
            __props__.__dict__["exp_nested_hvm"] = exp_nested_hvm
            __props__.__dict__["high_availability"] = high_availability
            __props__.__dict__["host"] = host
            __props__.__dict__["hvm_boot_firmware"] = hvm_boot_firmware
            __props__.__dict__["installation_method"] = installation_method
            if memory_max is None and not opts.urn:
                raise TypeError("Missing required property 'memory_max'")
            __props__.__dict__["memory_max"] = memory_max
            __props__.__dict__["name_description"] = name_description
            if name_label is None and not opts.urn:
                raise TypeError("Missing required property 'name_label'")
            __props__.__dict__["name_label"] = name_label
            if networks is None and not opts.urn:
                raise TypeError("Missing required property 'networks'")
            __props__.__dict__["networks"] = networks
            __props__.__dict__["power_state"] = power_state
            __props__.__dict__["resource_set"] = resource_set
            __props__.__dict__["start_delay"] = start_delay
            __props__.__dict__["tags"] = tags
            if template is None and not opts.urn:
                raise TypeError("Missing required property 'template'")
            __props__.__dict__["template"] = template
            __props__.__dict__["vga"] = vga
            __props__.__dict__["videoram"] = videoram
            __props__.__dict__["xenstore"] = xenstore
            __props__.__dict__["ipv4_addresses"] = None
            __props__.__dict__["ipv6_addresses"] = None
        super(Vm, __self__).__init__(
            'xenorchestra:index/vm:Vm',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            affinity_host: Optional[pulumi.Input[str]] = None,
            auto_poweron: Optional[pulumi.Input[bool]] = None,
            blocked_operations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            cdrom: Optional[pulumi.Input[Union['VmCdromArgs', 'VmCdromArgsDict']]] = None,
            clone_type: Optional[pulumi.Input[str]] = None,
            cloud_config: Optional[pulumi.Input[str]] = None,
            cloud_network_config: Optional[pulumi.Input[str]] = None,
            core_os: Optional[pulumi.Input[bool]] = None,
            cpu_cap: Optional[pulumi.Input[int]] = None,
            cpu_weight: Optional[pulumi.Input[int]] = None,
            cpus: Optional[pulumi.Input[int]] = None,
            destroy_cloud_config_vdi_after_boot: Optional[pulumi.Input[bool]] = None,
            disks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmDiskArgs', 'VmDiskArgsDict']]]]] = None,
            exp_nested_hvm: Optional[pulumi.Input[bool]] = None,
            high_availability: Optional[pulumi.Input[str]] = None,
            host: Optional[pulumi.Input[str]] = None,
            hvm_boot_firmware: Optional[pulumi.Input[str]] = None,
            installation_method: Optional[pulumi.Input[str]] = None,
            ipv4_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            memory_max: Optional[pulumi.Input[int]] = None,
            name_description: Optional[pulumi.Input[str]] = None,
            name_label: Optional[pulumi.Input[str]] = None,
            networks: Optional[pulumi.Input[Sequence[pulumi.Input[Union['VmNetworkArgs', 'VmNetworkArgsDict']]]]] = None,
            power_state: Optional[pulumi.Input[str]] = None,
            resource_set: Optional[pulumi.Input[str]] = None,
            start_delay: Optional[pulumi.Input[int]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            template: Optional[pulumi.Input[str]] = None,
            vga: Optional[pulumi.Input[str]] = None,
            videoram: Optional[pulumi.Input[int]] = None,
            xenstore: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None) -> 'Vm':
        """
        Get an existing Vm resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] affinity_host: The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
               be rescheduled.
        :param pulumi.Input[bool] auto_poweron: If the VM will automatically turn on. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_operations: List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
               hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
               can be found here
        :param pulumi.Input[Union['VmCdromArgs', 'VmCdromArgsDict']] cdrom: The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
               from `xe template-list`) and install the OS from the following ISO.
        :param pulumi.Input[str] clone_type: The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
               perform a `full` clone, the VM template must not be a disk template.
        :param pulumi.Input[str] cloud_config: The content of the cloud-init config to use. See the cloud init docs for more
               [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        :param pulumi.Input[str] cloud_network_config: The content of the cloud-init network configuration for the VM (uses [version
               1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        :param pulumi.Input[int] cpus: The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
               greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
               filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
               to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        :param pulumi.Input[bool] destroy_cloud_config_vdi_after_boot: Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
               power_state must be set to `Running`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['VmDiskArgs', 'VmDiskArgsDict']]]] disks: The disk the VM will have access to.
        :param pulumi.Input[bool] exp_nested_hvm: Boolean parameter that allows a VM to use nested virtualization.
        :param pulumi.Input[str] high_availability: The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
               Defaults to empty string
        :param pulumi.Input[str] hvm_boot_firmware: The firmware to use for the VM. Possible values are `bios` and `uefi`.
        :param pulumi.Input[str] installation_method: This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ipv6_addresses: This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network
               interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
        :param pulumi.Input[int] memory_max: The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
               value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
               xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
               memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
               stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        :param pulumi.Input[str] name_description: The description of the VM.
        :param pulumi.Input[str] name_label: The name of the VM.
        :param pulumi.Input[Sequence[pulumi.Input[Union['VmNetworkArgs', 'VmNetworkArgsDict']]]] networks: The network for the VM.
        :param pulumi.Input[str] power_state: The power state of the VM. This can be Running, Halted, Paused or Suspended.
        :param pulumi.Input[int] start_delay: Number of seconds the VM should be delayed from starting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The tags (labels) applied to the given entity.
        :param pulumi.Input[str] template: The ID of the VM template to create the new VM from.
        :param pulumi.Input[str] vga: The video adapter the VM should use. Possible values include std and cirrus.
        :param pulumi.Input[int] videoram: The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] xenstore: The key value pairs to be populated in xenstore.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _VmState.__new__(_VmState)

        __props__.__dict__["affinity_host"] = affinity_host
        __props__.__dict__["auto_poweron"] = auto_poweron
        __props__.__dict__["blocked_operations"] = blocked_operations
        __props__.__dict__["cdrom"] = cdrom
        __props__.__dict__["clone_type"] = clone_type
        __props__.__dict__["cloud_config"] = cloud_config
        __props__.__dict__["cloud_network_config"] = cloud_network_config
        __props__.__dict__["core_os"] = core_os
        __props__.__dict__["cpu_cap"] = cpu_cap
        __props__.__dict__["cpu_weight"] = cpu_weight
        __props__.__dict__["cpus"] = cpus
        __props__.__dict__["destroy_cloud_config_vdi_after_boot"] = destroy_cloud_config_vdi_after_boot
        __props__.__dict__["disks"] = disks
        __props__.__dict__["exp_nested_hvm"] = exp_nested_hvm
        __props__.__dict__["high_availability"] = high_availability
        __props__.__dict__["host"] = host
        __props__.__dict__["hvm_boot_firmware"] = hvm_boot_firmware
        __props__.__dict__["installation_method"] = installation_method
        __props__.__dict__["ipv4_addresses"] = ipv4_addresses
        __props__.__dict__["ipv6_addresses"] = ipv6_addresses
        __props__.__dict__["memory_max"] = memory_max
        __props__.__dict__["name_description"] = name_description
        __props__.__dict__["name_label"] = name_label
        __props__.__dict__["networks"] = networks
        __props__.__dict__["power_state"] = power_state
        __props__.__dict__["resource_set"] = resource_set
        __props__.__dict__["start_delay"] = start_delay
        __props__.__dict__["tags"] = tags
        __props__.__dict__["template"] = template
        __props__.__dict__["vga"] = vga
        __props__.__dict__["videoram"] = videoram
        __props__.__dict__["xenstore"] = xenstore
        return Vm(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="affinityHost")
    def affinity_host(self) -> pulumi.Output[Optional[str]]:
        """
        The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to
        be rescheduled.
        """
        return pulumi.get(self, "affinity_host")

    @property
    @pulumi.getter(name="autoPoweron")
    def auto_poweron(self) -> pulumi.Output[Optional[bool]]:
        """
        If the VM will automatically turn on. Defaults to `false`.
        """
        return pulumi.get(self, "auto_poweron")

    @property
    @pulumi.getter(name="blockedOperations")
    def blocked_operations(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,
        hard_shutdown, pause, shutdown, suspend, destroy. This can be used to prevent a VM from being destroyed. The entire list
        can be found here
        """
        return pulumi.get(self, "blocked_operations")

    @property
    @pulumi.getter
    def cdrom(self) -> pulumi.Output[Optional['outputs.VmCdrom']]:
        """
        The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available
        from `xe template-list`) and install the OS from the following ISO.
        """
        return pulumi.get(self, "cdrom")

    @property
    @pulumi.getter(name="cloneType")
    def clone_type(self) -> pulumi.Output[Optional[str]]:
        """
        The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to
        perform a `full` clone, the VM template must not be a disk template.
        """
        return pulumi.get(self, "clone_type")

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> pulumi.Output[Optional[str]]:
        """
        The content of the cloud-init config to use. See the cloud init docs for more
        [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).
        """
        return pulumi.get(self, "cloud_config")

    @property
    @pulumi.getter(name="cloudNetworkConfig")
    def cloud_network_config(self) -> pulumi.Output[Optional[str]]:
        """
        The content of the cloud-init network configuration for the VM (uses [version
        1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))
        """
        return pulumi.get(self, "cloud_network_config")

    @property
    @pulumi.getter(name="coreOs")
    def core_os(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "core_os")

    @property
    @pulumi.getter(name="cpuCap")
    def cpu_cap(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "cpu_cap")

    @property
    @pulumi.getter(name="cpuWeight")
    def cpu_weight(self) -> pulumi.Output[Optional[int]]:
        return pulumi.get(self, "cpu_weight")

    @property
    @pulumi.getter
    def cpus(self) -> pulumi.Output[int]:
        """
        The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is
        greater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects
        filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].CPUs' { "max": 4, "number": 2 } # Updating the VM
        to use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="destroyCloudConfigVdiAfterBoot")
    def destroy_cloud_config_vdi_after_boot(self) -> pulumi.Output[Optional[bool]]:
        """
        Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,
        power_state must be set to `Running`.
        """
        return pulumi.get(self, "destroy_cloud_config_vdi_after_boot")

    @property
    @pulumi.getter
    def disks(self) -> pulumi.Output[Sequence['outputs.VmDisk']]:
        """
        The disk the VM will have access to.
        """
        return pulumi.get(self, "disks")

    @property
    @pulumi.getter(name="expNestedHvm")
    def exp_nested_hvm(self) -> pulumi.Output[Optional[bool]]:
        """
        Boolean parameter that allows a VM to use nested virtualization.
        """
        return pulumi.get(self, "exp_nested_hvm")

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> pulumi.Output[Optional[str]]:
        """
        The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.
        Defaults to empty string
        """
        return pulumi.get(self, "high_availability")

    @property
    @pulumi.getter
    def host(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="hvmBootFirmware")
    def hvm_boot_firmware(self) -> pulumi.Output[Optional[str]]:
        """
        The firmware to use for the VM. Possible values are `bios` and `uefi`.
        """
        return pulumi.get(self, "hvm_boot_firmware")

    @property
    @pulumi.getter(name="installationMethod")
    def installation_method(self) -> pulumi.Output[Optional[str]]:
        """
        This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.
        """
        return pulumi.get(self, "installation_method")

    @property
    @pulumi.getter(name="ipv4Addresses")
    def ipv4_addresses(self) -> pulumi.Output[Sequence[str]]:
        return pulumi.get(self, "ipv4_addresses")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> pulumi.Output[Sequence[str]]:
        """
        This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network
        interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="memoryMax")
    def memory_max(self) -> pulumi.Output[int]:
        """
        The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new
        value is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli
        xo.getAllObjects filter='json:{"id": "cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8"}' | jq '.[].memory.dynamic' [ 2147483648, #
        memory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without
        stopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```
        """
        return pulumi.get(self, "memory_max")

    @property
    @pulumi.getter(name="nameDescription")
    def name_description(self) -> pulumi.Output[Optional[str]]:
        """
        The description of the VM.
        """
        return pulumi.get(self, "name_description")

    @property
    @pulumi.getter(name="nameLabel")
    def name_label(self) -> pulumi.Output[str]:
        """
        The name of the VM.
        """
        return pulumi.get(self, "name_label")

    @property
    @pulumi.getter
    def networks(self) -> pulumi.Output[Sequence['outputs.VmNetwork']]:
        """
        The network for the VM.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="powerState")
    def power_state(self) -> pulumi.Output[Optional[str]]:
        """
        The power state of the VM. This can be Running, Halted, Paused or Suspended.
        """
        return pulumi.get(self, "power_state")

    @property
    @pulumi.getter(name="resourceSet")
    def resource_set(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "resource_set")

    @property
    @pulumi.getter(name="startDelay")
    def start_delay(self) -> pulumi.Output[Optional[int]]:
        """
        Number of seconds the VM should be delayed from starting.
        """
        return pulumi.get(self, "start_delay")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        The tags (labels) applied to the given entity.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def template(self) -> pulumi.Output[str]:
        """
        The ID of the VM template to create the new VM from.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def vga(self) -> pulumi.Output[Optional[str]]:
        """
        The video adapter the VM should use. Possible values include std and cirrus.
        """
        return pulumi.get(self, "vga")

    @property
    @pulumi.getter
    def videoram(self) -> pulumi.Output[Optional[int]]:
        """
        The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16
        """
        return pulumi.get(self, "videoram")

    @property
    @pulumi.getter
    def xenstore(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        The key value pairs to be populated in xenstore.
        """
        return pulumi.get(self, "xenstore")

