{
    "name": "xenorchestra",
    "description": "A Pulumi package for creating and managing Xen Orchestra cloud resources.",
    "keywords": [
        "pulumi",
        "xenorchestra",
        "category/cloud"
    ],
    "homepage": "https://www.pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`xenorchestra` Terraform Provider](https://github.com/vatesfr/terraform-provider-xenorchestra).",
    "repository": "https://github.com/vatesfr/pulumi-xenorchestra",
    "logoUrl": "https://raw.githubusercontent.com/vatesfr/pulumi-xenorchestra/8c71624229d953d4fb7d4843d5483e53e21b9459/logo_xo.png",
    "pluginDownloadURL": "github://api.github.com/vatesfr/pulumi-xenorchestra",
    "publisher": "Vates",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageName": "@vates/pulumi-xenorchestra",
            "packageDescription": "A Pulumi package for creating and managing Xen Orchestra cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/vatesfr/terraform-provider-xenorchestra)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-xenorchestra` repo](https://github.com/vatesfr/pulumi-xenorchestra/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-xenorchestra` repo](https://github.com/vatesfr/terraform-provider-xenorchestra/issues).",
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/vatesfr/terraform-provider-xenorchestra)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-xenorchestra` repo](https://github.com/vatesfr/pulumi-xenorchestra/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-xenorchestra` repo](https://github.com/vatesfr/terraform-provider-xenorchestra/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "insecure": {
                "type": "boolean",
                "description": "Whether SSL should be verified or not. Can be set via the XOA_INSECURE environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_PASSWORD environment variable.\n"
            },
            "retryMaxTime": {
                "type": "string",
                "description": "If `retry_mode` is set, this specifies the duration for which the backoff method will continue retries. Can be set via\nthe `XOA_RETRY_MAX_TIME` environment variable\n"
            },
            "retryMode": {
                "type": "string",
                "description": "Specifies if retries should be attempted for requests that require eventual . Can be set via the XOA_RETRY_MODE\nenvironment variable.\n"
            },
            "token": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_TOKEN environment variable.\n"
            },
            "url": {
                "type": "string",
                "description": "Hostname of the xoa router. Can be set via the XOA_URL environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "User account for xoa api. Can be set via the XOA_USER environment variable.\n"
            }
        },
        "defaults": [
            "url"
        ]
    },
    "types": {
        "xenorchestra:index/ResourceSetLimit:ResourceSetLimit": {
            "properties": {
                "quantity": {
                    "type": "integer",
                    "description": "The numerical limit for the given type.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of resource set limit. Must be cpus, memory or disk.\n"
                }
            },
            "type": "object",
            "required": [
                "quantity",
                "type"
            ]
        },
        "xenorchestra:index/VmCdrom:VmCdrom": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the ISO (VDI) to attach to the VM. This can be easily provided by using the `vdi` data source.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "xenorchestra:index/VmDisk:VmDisk": {
            "properties": {
                "attached": {
                    "type": "boolean",
                    "description": "Whether the device should be attached to the VM.\n"
                },
                "nameDescription": {
                    "type": "string",
                    "description": "The description for the disk\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name for the disk\n"
                },
                "position": {
                    "type": "string",
                    "description": "Indicates the order of the block device.\n"
                },
                "size": {
                    "type": "number",
                    "description": "The size in bytes for the disk.\n"
                },
                "srId": {
                    "type": "string",
                    "description": "The storage repository ID to use.\n"
                },
                "vbdId": {
                    "type": "string"
                },
                "vdiId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "nameLabel",
                "size",
                "srId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "nameLabel",
                        "position",
                        "size",
                        "srId",
                        "vbdId",
                        "vdiId"
                    ]
                }
            }
        },
        "xenorchestra:index/VmNetwork:VmNetwork": {
            "properties": {
                "attached": {
                    "type": "boolean",
                    "description": "Whether the device should be attached to the VM.\n"
                },
                "device": {
                    "type": "string"
                },
                "expectedIpCidr": {
                    "type": "string"
                },
                "ipv4Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "macAddress": {
                    "type": "string"
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network the VM will be on.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "device",
                        "ipv4Addresses",
                        "ipv6Addresses",
                        "macAddress",
                        "networkId"
                    ]
                }
            }
        },
        "xenorchestra:index/getXoaHostsHost:getXoaHostsHost": {
            "properties": {
                "cpus": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.\n"
                },
                "id": {
                    "type": "string"
                },
                "memory": {
                    "type": "integer",
                    "description": "The memory size of the host.\n"
                },
                "memoryUsage": {
                    "type": "integer",
                    "description": "The memory usage of the host.\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the host.\n"
                },
                "poolId": {
                    "type": "string",
                    "description": "Id of the pool that the host belongs to.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The tags (labels) applied to the given entity.\n"
                }
            },
            "type": "object",
            "required": [
                "cpus",
                "id",
                "memory",
                "memoryUsage",
                "nameLabel",
                "poolId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "xenorchestra:index/getXoaVmsVm:getXoaVmsVm": {
            "properties": {
                "affinityHost": {
                    "type": "string",
                    "description": "The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to be rescheduled.\n"
                },
                "autoPoweron": {
                    "type": "boolean",
                    "description": "If the VM will automatically turn on. Defaults to `false`.\n"
                },
                "blockedOperations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot, hard_shutdown, pause, shutdown, suspend, destroy. See: https://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations\n"
                },
                "cloneType": {
                    "type": "string",
                    "description": "The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to perform a `full` clone, the VM template must not be a disk template.\n"
                },
                "cloudConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init config to use. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n"
                },
                "cloudNetworkConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init network configuration for the VM (uses [version 1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))\n"
                },
                "coreOs": {
                    "type": "boolean"
                },
                "cpuCap": {
                    "type": "integer"
                },
                "cpuWeight": {
                    "type": "integer"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is greater than the max CPU value. This can be determined with the following command:\n```\n\n$ xo-cli xo.getAllObjects filter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].CPUs'\n{\n  \"max\": 4,\n  \"number\": 2\n}\n\n# Updating the VM to use 3 CPUs would happen without stopping/starting the VM\n# Updating the VM to use 5 CPUs would stop/start the VM\n```\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/getXoaVmsVmDisk:getXoaVmsVmDisk"
                    },
                    "description": "The disk the VM will have access to.\n"
                },
                "expNestedHvm": {
                    "type": "boolean",
                    "description": "Boolean parameter that allows a VM to use nested virtualization.\n"
                },
                "highAvailability": {
                    "type": "string",
                    "description": "The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure. Defaults to empty string\n"
                },
                "host": {
                    "type": "string"
                },
                "hvmBootFirmware": {
                    "type": "string",
                    "description": "The firmware to use for the VM. Possible values are `bios` and `uefi`.\n"
                },
                "id": {
                    "type": "string"
                },
                "ipv4Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network interfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.\n"
                },
                "memoryMax": {
                    "type": "integer",
                    "description": "The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new value is greater than the dynamic memory max. This can be determined with the following command:\n```\n\n\n$ xo-cli xo.getAllObjects filter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].memory.dynamic'\n[\n  2147483648, # memory dynamic min\n  4294967296  # memory dynamic max (4GB)\n]\n# Updating the VM to use 3GB of memory would happen without stopping/starting the VM\n# Updating the VM to use 5GB of memory would stop/start the VM\n```\n"
                },
                "nameDescription": {
                    "type": "string",
                    "description": "The description of the VM.\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name of the VM.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/getXoaVmsVmNetwork:getXoaVmsVmNetwork"
                    },
                    "description": "The network for the VM.\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "The power state of the VM. This can be Running, Halted, Paused or Suspended.\n"
                },
                "resourceSet": {
                    "type": "string"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Number of seconds the VM should be delayed from starting.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The tags (labels) applied to the given entity.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The ID of the VM template to create the new VM from.\n"
                },
                "vga": {
                    "type": "string",
                    "description": "The video adapter the VM should use. Possible values include std and cirrus.\n"
                },
                "videoram": {
                    "type": "integer",
                    "description": "The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16\n"
                },
                "xenstore": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The key value pairs to be populated in xenstore.\n"
                }
            },
            "type": "object",
            "required": [
                "cpus",
                "disks",
                "id",
                "ipv4Addresses",
                "ipv6Addresses",
                "memoryMax",
                "nameLabel",
                "networks",
                "template"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "xenorchestra:index/getXoaVmsVmDisk:getXoaVmsVmDisk": {
            "properties": {
                "attached": {
                    "type": "boolean",
                    "description": "Whether the device should be attached to the VM.\n"
                },
                "nameDescription": {
                    "type": "string",
                    "description": "The description for the disk\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name for the disk\n"
                },
                "position": {
                    "type": "string",
                    "description": "Indicates the order of the block device.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size in bytes for the disk.\n"
                },
                "srId": {
                    "type": "string",
                    "description": "The storage repository ID to use.\n"
                },
                "vbdId": {
                    "type": "string"
                },
                "vdiId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "nameLabel",
                "position",
                "size",
                "srId",
                "vbdId",
                "vdiId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "xenorchestra:index/getXoaVmsVmNetwork:getXoaVmsVmNetwork": {
            "properties": {
                "attached": {
                    "type": "boolean",
                    "description": "Whether the device should be attached to the VM.\n"
                },
                "device": {
                    "type": "string"
                },
                "expectedIpCidr": {
                    "type": "string"
                },
                "ipv4Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "macAddress": {
                    "type": "string"
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network the VM will be on.\n"
                }
            },
            "type": "object",
            "required": [
                "device",
                "ipv4Addresses",
                "ipv6Addresses",
                "macAddress",
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the xenorchestra package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "insecure": {
                "type": "boolean",
                "description": "Whether SSL should be verified or not. Can be set via the XOA_INSECURE environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_PASSWORD environment variable.\n"
            },
            "retryMaxTime": {
                "type": "string",
                "description": "If `retry_mode` is set, this specifies the duration for which the backoff method will continue retries. Can be set via\nthe `XOA_RETRY_MAX_TIME` environment variable\n"
            },
            "retryMode": {
                "type": "string",
                "description": "Specifies if retries should be attempted for requests that require eventual . Can be set via the XOA_RETRY_MODE\nenvironment variable.\n"
            },
            "token": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_TOKEN environment variable.\n"
            },
            "url": {
                "type": "string",
                "description": "Hostname of the xoa router. Can be set via the XOA_URL environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "User account for xoa api. Can be set via the XOA_USER environment variable.\n"
            }
        },
        "required": [
            "url"
        ],
        "inputProperties": {
            "insecure": {
                "type": "boolean",
                "description": "Whether SSL should be verified or not. Can be set via the XOA_INSECURE environment variable.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_PASSWORD environment variable.\n"
            },
            "retryMaxTime": {
                "type": "string",
                "description": "If `retry_mode` is set, this specifies the duration for which the backoff method will continue retries. Can be set via\nthe `XOA_RETRY_MAX_TIME` environment variable\n"
            },
            "retryMode": {
                "type": "string",
                "description": "Specifies if retries should be attempted for requests that require eventual . Can be set via the XOA_RETRY_MODE\nenvironment variable.\n"
            },
            "token": {
                "type": "string",
                "description": "Password for xoa api. Can be set via the XOA_TOKEN environment variable.\n"
            },
            "url": {
                "type": "string",
                "description": "Hostname of the xoa router. Can be set via the XOA_URL environment variable.\n"
            },
            "username": {
                "type": "string",
                "description": "User account for xoa api. Can be set via the XOA_USER environment variable.\n"
            }
        },
        "requiredInputs": [
            "url"
        ]
    },
    "resources": {
        "xenorchestra:index/acl:Acl": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst pool = xenorchestra.getXoaPool({\n    nameLabel: \"Your pool\",\n});\nconst user = xenorchestra.getXoaUser({\n    username: \"my-username\",\n});\nconst acl = new xenorchestra.Acl(\"acl\", {\n    subject: user.then(user =\u003e user.id),\n    object: pool.then(pool =\u003e pool.id),\n    action: \"operator\",\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\npool = xenorchestra.get_xoa_pool(name_label=\"Your pool\")\nuser = xenorchestra.get_xoa_user(username=\"my-username\")\nacl = xenorchestra.Acl(\"acl\",\n    subject=user.id,\n    object=pool.id,\n    action=\"operator\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = Xenorchestra.GetXoaPool.Invoke(new()\n    {\n        NameLabel = \"Your pool\",\n    });\n\n    var user = Xenorchestra.GetXoaUser.Invoke(new()\n    {\n        Username = \"my-username\",\n    });\n\n    var acl = new Xenorchestra.Acl(\"acl\", new()\n    {\n        Subject = user.Apply(getXoaUserResult =\u003e getXoaUserResult.Id),\n        Object = pool.Apply(getXoaPoolResult =\u003e getXoaPoolResult.Id),\n        Action = \"operator\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpool, err := xenorchestra.GetXoaPool(ctx, \u0026xenorchestra.GetXoaPoolArgs{\n\t\t\tNameLabel: \"Your pool\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := xenorchestra.GetXoaUser(ctx, \u0026xenorchestra.GetXoaUserArgs{\n\t\t\tUsername: \"my-username\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewAcl(ctx, \"acl\", \u0026xenorchestra.AclArgs{\n\t\t\tSubject: pulumi.String(user.Id),\n\t\t\tObject:  pulumi.String(pool.Id),\n\t\t\tAction:  pulumi.String(\"operator\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaPoolArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaUserArgs;\nimport com.pulumi.xenorchestra.Acl;\nimport com.pulumi.xenorchestra.AclArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pool = XenorchestraFunctions.getXoaPool(GetXoaPoolArgs.builder()\n            .nameLabel(\"Your pool\")\n            .build());\n\n        final var user = XenorchestraFunctions.getXoaUser(GetXoaUserArgs.builder()\n            .username(\"my-username\")\n            .build());\n\n        var acl = new Acl(\"acl\", AclArgs.builder()\n            .subject(user.id())\n            .object(pool.id())\n            .action(\"operator\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  acl:\n    type: xenorchestra:Acl\n    properties:\n      subject: ${user.id}\n      object: ${pool.id}\n      action: operator\nvariables:\n  pool:\n    fn::invoke:\n      function: xenorchestra:getXoaPool\n      arguments:\n        nameLabel: Your pool\n  user:\n    fn::invoke:\n      function: xenorchestra:getXoaUser\n      arguments:\n        username: my-username\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Must be one of admin, operator, viewer. See the [Xen orchestra docs](https://xen-orchestra.com/docs/acls.html) on ACLs for more details.\n"
                },
                "object": {
                    "type": "string",
                    "description": "The id of the object that will be able to be used by the subject.\n"
                },
                "subject": {
                    "type": "string",
                    "description": "The uuid of the user account that the acl will apply to.\n"
                }
            },
            "required": [
                "action",
                "object",
                "subject"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "Must be one of admin, operator, viewer. See the [Xen orchestra docs](https://xen-orchestra.com/docs/acls.html) on ACLs for more details.\n",
                    "willReplaceOnChanges": true
                },
                "object": {
                    "type": "string",
                    "description": "The id of the object that will be able to be used by the subject.\n",
                    "willReplaceOnChanges": true
                },
                "subject": {
                    "type": "string",
                    "description": "The uuid of the user account that the acl will apply to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "action",
                "object",
                "subject"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Acl resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "Must be one of admin, operator, viewer. See the [Xen orchestra docs](https://xen-orchestra.com/docs/acls.html) on ACLs for more details.\n",
                        "willReplaceOnChanges": true
                    },
                    "object": {
                        "type": "string",
                        "description": "The id of the object that will be able to be used by the subject.\n",
                        "willReplaceOnChanges": true
                    },
                    "subject": {
                        "type": "string",
                        "description": "The uuid of the user account that the acl will apply to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "xenorchestra:index/cloudConfig:CloudConfig": {
            "description": "Creates a Xen Orchestra cloud config resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst demo = new xenorchestra.CloudConfig(\"demo\", {\n    name: \"cloud config name\",\n    template: `#cloud-config\n\nruncmd:\n - [ ls, -l, / ]\n - [ sh, -xc, \"echo (date) ': hello world!'\" ]\n - [ sh, -c, echo \"=========hello world'=========\" ]\n - ls -l /root\n`,\n});\nconst bar = new xenorchestra.Vm(\"bar\", {cloudConfig: demo.template});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\ndemo = xenorchestra.CloudConfig(\"demo\",\n    name=\"cloud config name\",\n    template=\"\"\"#cloud-config\n\nruncmd:\n - [ ls, -l, / ]\n - [ sh, -xc, \"echo $(date) ': hello world!'\" ]\n - [ sh, -c, echo \"=========hello world'=========\" ]\n - ls -l /root\n\"\"\")\nbar = xenorchestra.Vm(\"bar\", cloud_config=demo.template)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demo = new Xenorchestra.CloudConfig(\"demo\", new()\n    {\n        Name = \"cloud config name\",\n        Template = @\"#cloud-config\n\nruncmd:\n - [ ls, -l, / ]\n - [ sh, -xc, \"\"echo $(date) ': hello world!'\"\" ]\n - [ sh, -c, echo \"\"=========hello world'=========\"\" ]\n - ls -l /root\n\",\n    });\n\n    var bar = new Xenorchestra.Vm(\"bar\", new()\n    {\n        CloudConfig = demo.Template,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdemo, err := xenorchestra.NewCloudConfig(ctx, \"demo\", \u0026xenorchestra.CloudConfigArgs{\n\t\t\tName: pulumi.String(\"cloud config name\"),\n\t\t\tTemplate: pulumi.String(`#cloud-config\n\nruncmd:\n - [ ls, -l, / ]\n - [ sh, -xc, \"echo $(date) ': hello world!'\" ]\n - [ sh, -c, echo \"=========hello world'=========\" ]\n - ls -l /root\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"bar\", \u0026xenorchestra.VmArgs{\n\t\t\tCloudConfig: demo.Template,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.CloudConfig;\nimport com.pulumi.xenorchestra.CloudConfigArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demo = new CloudConfig(\"demo\", CloudConfigArgs.builder()\n            .name(\"cloud config name\")\n            .template(\"\"\"\n#cloud-config\n\nruncmd:\n - [ ls, -l, / ]\n - [ sh, -xc, \"echo $(date) ': hello world!'\" ]\n - [ sh, -c, echo \"=========hello world'=========\" ]\n - ls -l /root\n            \"\"\")\n            .build());\n\n        var bar = new Vm(\"bar\", VmArgs.builder()\n            .cloudConfig(demo.template())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo:\n    type: xenorchestra:CloudConfig\n    properties:\n      name: cloud config name\n      template: |\n        #cloud-config\n\n        runcmd:\n         - [ ls, -l, / ]\n         - [ sh, -xc, \"echo $(date) ': hello world!'\" ]\n         - [ sh, -c, echo \"=========hello world'=========\" ]\n         - ls -l /root\n  bar:\n    type: xenorchestra:Vm\n    properties:\n      cloudConfig: ${demo.template}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the cloud config.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The cloud init config. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n"
                }
            },
            "required": [
                "name",
                "template"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the cloud config.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "The cloud init config. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "template"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudConfig resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the cloud config.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "type": "string",
                        "description": "The cloud init config. See the cloud init docs for more [information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "xenorchestra:index/resourceSet:ResourceSet": {
            "description": "Creates a Xen Orchestra resource set.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst template = xenorchestra.getXoaTemplate({\n    nameLabel: \"Ubuntu Bionic Beaver 18.04\",\n});\nconst sr = xenorchestra.getXoaStorageRepository({\n    nameLabel: \"Your storage repository label\",\n});\nconst eth0 = xenorchestra.getXoaPif({\n    device: \"eth0\",\n    vlan: -1,\n});\nconst user = xenorchestra.getXoaUser({\n    username: \"test_user\",\n});\nconst rs = new xenorchestra.ResourceSet(\"rs\", {\n    name: \"new-resource-set\",\n    subjects: [user.then(user =\u003e user.id)],\n    objects: [\n        template.then(template =\u003e template.id),\n        sr.then(sr =\u003e sr.id),\n        eth0.then(eth0 =\u003e eth0.network),\n    ],\n    limits: [\n        {\n            type: \"cpus\",\n            quantity: 20,\n        },\n        {\n            type: \"disk\",\n            quantity: 107374182400,\n        },\n        {\n            type: \"memory\",\n            quantity: 12884901888,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\ntemplate = xenorchestra.get_xoa_template(name_label=\"Ubuntu Bionic Beaver 18.04\")\nsr = xenorchestra.get_xoa_storage_repository(name_label=\"Your storage repository label\")\neth0 = xenorchestra.get_xoa_pif(device=\"eth0\",\n    vlan=-1)\nuser = xenorchestra.get_xoa_user(username=\"test_user\")\nrs = xenorchestra.ResourceSet(\"rs\",\n    name=\"new-resource-set\",\n    subjects=[user.id],\n    objects=[\n        template.id,\n        sr.id,\n        eth0.network,\n    ],\n    limits=[\n        {\n            \"type\": \"cpus\",\n            \"quantity\": 20,\n        },\n        {\n            \"type\": \"disk\",\n            \"quantity\": 107374182400,\n        },\n        {\n            \"type\": \"memory\",\n            \"quantity\": 12884901888,\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var template = Xenorchestra.GetXoaTemplate.Invoke(new()\n    {\n        NameLabel = \"Ubuntu Bionic Beaver 18.04\",\n    });\n\n    var sr = Xenorchestra.GetXoaStorageRepository.Invoke(new()\n    {\n        NameLabel = \"Your storage repository label\",\n    });\n\n    var eth0 = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth0\",\n        Vlan = -1,\n    });\n\n    var user = Xenorchestra.GetXoaUser.Invoke(new()\n    {\n        Username = \"test_user\",\n    });\n\n    var rs = new Xenorchestra.ResourceSet(\"rs\", new()\n    {\n        Name = \"new-resource-set\",\n        Subjects = new[]\n        {\n            user.Apply(getXoaUserResult =\u003e getXoaUserResult.Id),\n        },\n        Objects = new[]\n        {\n            template.Apply(getXoaTemplateResult =\u003e getXoaTemplateResult.Id),\n            sr.Apply(getXoaStorageRepositoryResult =\u003e getXoaStorageRepositoryResult.Id),\n            eth0.Apply(getXoaPifResult =\u003e getXoaPifResult.Network),\n        },\n        Limits = new[]\n        {\n            new Xenorchestra.Inputs.ResourceSetLimitArgs\n            {\n                Type = \"cpus\",\n                Quantity = 20,\n            },\n            new Xenorchestra.Inputs.ResourceSetLimitArgs\n            {\n                Type = \"disk\",\n                Quantity = 107374182400,\n            },\n            new Xenorchestra.Inputs.ResourceSetLimitArgs\n            {\n                Type = \"memory\",\n                Quantity = 12884901888,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttemplate, err := xenorchestra.GetXoaTemplate(ctx, \u0026xenorchestra.GetXoaTemplateArgs{\n\t\t\tNameLabel: \"Ubuntu Bionic Beaver 18.04\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsr, err := xenorchestra.GetXoaStorageRepository(ctx, \u0026xenorchestra.GetXoaStorageRepositoryArgs{\n\t\t\tNameLabel: \"Your storage repository label\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\teth0, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth0\",\n\t\t\tVlan:   -1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := xenorchestra.GetXoaUser(ctx, \u0026xenorchestra.GetXoaUserArgs{\n\t\t\tUsername: \"test_user\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewResourceSet(ctx, \"rs\", \u0026xenorchestra.ResourceSetArgs{\n\t\t\tName: pulumi.String(\"new-resource-set\"),\n\t\t\tSubjects: pulumi.StringArray{\n\t\t\t\tpulumi.String(user.Id),\n\t\t\t},\n\t\t\tObjects: pulumi.StringArray{\n\t\t\t\tpulumi.String(template.Id),\n\t\t\t\tpulumi.String(sr.Id),\n\t\t\t\tpulumi.String(eth0.Network),\n\t\t\t},\n\t\t\tLimits: xenorchestra.ResourceSetLimitArray{\n\t\t\t\t\u0026xenorchestra.ResourceSetLimitArgs{\n\t\t\t\t\tType:     pulumi.String(\"cpus\"),\n\t\t\t\t\tQuantity: pulumi.Int(20),\n\t\t\t\t},\n\t\t\t\t\u0026xenorchestra.ResourceSetLimitArgs{\n\t\t\t\t\tType:     pulumi.String(\"disk\"),\n\t\t\t\t\tQuantity: pulumi.Int(107374182400),\n\t\t\t\t},\n\t\t\t\t\u0026xenorchestra.ResourceSetLimitArgs{\n\t\t\t\t\tType:     pulumi.String(\"memory\"),\n\t\t\t\t\tQuantity: pulumi.Int(12884901888),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaTemplateArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaStorageRepositoryArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaPifArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaUserArgs;\nimport com.pulumi.xenorchestra.ResourceSet;\nimport com.pulumi.xenorchestra.ResourceSetArgs;\nimport com.pulumi.xenorchestra.inputs.ResourceSetLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var template = XenorchestraFunctions.getXoaTemplate(GetXoaTemplateArgs.builder()\n            .nameLabel(\"Ubuntu Bionic Beaver 18.04\")\n            .build());\n\n        final var sr = XenorchestraFunctions.getXoaStorageRepository(GetXoaStorageRepositoryArgs.builder()\n            .nameLabel(\"Your storage repository label\")\n            .build());\n\n        final var eth0 = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth0\")\n            .vlan(-1)\n            .build());\n\n        final var user = XenorchestraFunctions.getXoaUser(GetXoaUserArgs.builder()\n            .username(\"test_user\")\n            .build());\n\n        var rs = new ResourceSet(\"rs\", ResourceSetArgs.builder()\n            .name(\"new-resource-set\")\n            .subjects(user.id())\n            .objects(            \n                template.id(),\n                sr.id(),\n                eth0.network())\n            .limits(            \n                ResourceSetLimitArgs.builder()\n                    .type(\"cpus\")\n                    .quantity(20)\n                    .build(),\n                ResourceSetLimitArgs.builder()\n                    .type(\"disk\")\n                    .quantity(107374182400)\n                    .build(),\n                ResourceSetLimitArgs.builder()\n                    .type(\"memory\")\n                    .quantity(12884901888)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rs:\n    type: xenorchestra:ResourceSet\n    properties:\n      name: new-resource-set\n      subjects:\n        - ${user.id}\n      objects:\n        - ${template.id}\n        - ${sr.id}\n        - ${eth0.network}\n      limits:\n        - type: cpus\n          quantity: 20\n        - type: disk\n          quantity: 1.073741824e+11\n        - type: memory\n          quantity: 1.2884901888e+10\nvariables:\n  template:\n    fn::invoke:\n      function: xenorchestra:getXoaTemplate\n      arguments:\n        nameLabel: Ubuntu Bionic Beaver 18.04\n  sr:\n    fn::invoke:\n      function: xenorchestra:getXoaStorageRepository\n      arguments:\n        nameLabel: Your storage repository label\n  eth0:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth0\n        vlan: -1\n  user:\n    fn::invoke:\n      function: xenorchestra:getXoaUser\n      arguments:\n        username: test_user\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nID can be found from the following command:\n\n$ xo-cli resourceSet.getAll\n\n```sh\n$ pulumi import xenorchestra:index/resourceSet:ResourceSet rs MGSpuwnbtUE\n```\n\n",
            "properties": {
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/ResourceSetLimit:ResourceSetLimit"
                    },
                    "description": "The limit applied to the resource set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource set.\n"
                },
                "objects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The uuids of the objects that are within scope of the resource set. A minimum of a storage repository, network and VM template are required for users to launch VMs.\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The uuids of the user accounts that should have access to the resource set.\n"
                }
            },
            "required": [
                "limits",
                "name"
            ],
            "inputProperties": {
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/ResourceSetLimit:ResourceSetLimit"
                    },
                    "description": "The limit applied to the resource set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource set.\n"
                },
                "objects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The uuids of the objects that are within scope of the resource set. A minimum of a storage repository, network and VM template are required for users to launch VMs.\n"
                },
                "subjects": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The uuids of the user accounts that should have access to the resource set.\n"
                }
            },
            "requiredInputs": [
                "limits"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourceSet resources.\n",
                "properties": {
                    "limits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/xenorchestra:index/ResourceSetLimit:ResourceSetLimit"
                        },
                        "description": "The limit applied to the resource set.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource set.\n"
                    },
                    "objects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The uuids of the objects that are within scope of the resource set. A minimum of a storage repository, network and VM template are required for users to launch VMs.\n"
                    },
                    "subjects": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The uuids of the user accounts that should have access to the resource set.\n"
                    }
                },
                "type": "object"
            }
        },
        "xenorchestra:index/vdi:Vdi": {
            "description": "Creates a Xen Orchestra vdi resource.\n\n",
            "properties": {
                "filepath": {
                    "type": "string",
                    "description": "The file path to the ISO or vdi image that should be uploaded when the VDI is created.\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the VDI\n"
                },
                "srId": {
                    "type": "string",
                    "description": "The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Only `raw` uploads are supported today, but vhd support may be added in the future.\n"
                }
            },
            "required": [
                "filepath",
                "nameLabel",
                "srId",
                "type"
            ],
            "inputProperties": {
                "filepath": {
                    "type": "string",
                    "description": "The file path to the ISO or vdi image that should be uploaded when the VDI is created.\n",
                    "willReplaceOnChanges": true
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the VDI\n"
                },
                "srId": {
                    "type": "string",
                    "description": "The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Only `raw` uploads are supported today, but vhd support may be added in the future.\n"
                }
            },
            "requiredInputs": [
                "filepath",
                "nameLabel",
                "srId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vdi resources.\n",
                "properties": {
                    "filepath": {
                        "type": "string",
                        "description": "The file path to the ISO or vdi image that should be uploaded when the VDI is created.\n",
                        "willReplaceOnChanges": true
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name label of the VDI\n"
                    },
                    "srId": {
                        "type": "string",
                        "description": "The id of the storage repository the VDI should be created in. Make sure the storage repository supports the file you are uploading! For example, ISOs should only be uploaded to ISO storage repositories.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Only `raw` uploads are supported today, but vhd support may be added in the future.\n"
                    }
                },
                "type": "object"
            }
        },
        "xenorchestra:index/vm:Vm": {
            "description": "## Example Usage\n\n",
            "properties": {
                "affinityHost": {
                    "type": "string",
                    "description": "The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to\nbe rescheduled.\n"
                },
                "autoPoweron": {
                    "type": "boolean",
                    "description": "If the VM will automatically turn on. Defaults to `false`.\n"
                },
                "blockedOperations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,\nhard_shutdown, pause, shutdown, suspend, destroy. See:\nhttps://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations\n"
                },
                "cdrom": {
                    "$ref": "#/types/xenorchestra:index/VmCdrom:VmCdrom",
                    "description": "The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available\nfrom `xe template-list`) and install the OS from the following ISO.\n"
                },
                "cloneType": {
                    "type": "string",
                    "description": "The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to\nperform a `full` clone, the VM template must not be a disk template.\n"
                },
                "cloudConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init config to use. See the cloud init docs for more\n[information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n"
                },
                "cloudNetworkConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init network configuration for the VM (uses [version\n1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))\n"
                },
                "coreOs": {
                    "type": "boolean"
                },
                "cpuCap": {
                    "type": "integer"
                },
                "cpuWeight": {
                    "type": "integer"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is\ngreater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects\nfilter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].CPUs' { \"max\": 4, \"number\": 2 } # Updating the VM\nto use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```\n"
                },
                "destroyCloudConfigVdiAfterBoot": {
                    "type": "boolean",
                    "description": "Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,\npower_state must be set to `Running`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/VmDisk:VmDisk"
                    },
                    "description": "The disk the VM will have access to.\n"
                },
                "expNestedHvm": {
                    "type": "boolean",
                    "description": "Boolean parameter that allows a VM to use nested virtualization.\n"
                },
                "highAvailability": {
                    "type": "string",
                    "description": "The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.\nDefaults to empty string\n"
                },
                "host": {
                    "type": "string"
                },
                "hvmBootFirmware": {
                    "type": "string",
                    "description": "The firmware to use for the VM. Possible values are `bios` and `uefi`.\n"
                },
                "installationMethod": {
                    "type": "string",
                    "description": "This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.\n"
                },
                "ipv4Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv6Addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network\ninterfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.\n"
                },
                "memoryMax": {
                    "type": "number",
                    "description": "The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new\nvalue is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli\nxo.getAllObjects filter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].memory.dynamic' [ 2147483648, #\nmemory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without\nstopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```\n"
                },
                "nameDescription": {
                    "type": "string",
                    "description": "The description of the VM.\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name of the VM.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/VmNetwork:VmNetwork"
                    },
                    "description": "The network for the VM.\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "The power state of the VM. This can be Running, Halted, Paused or Suspended.\n"
                },
                "resourceSet": {
                    "type": "string"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Number of seconds the VM should be delayed from starting.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The tags (labels) applied to the given entity.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The ID of the VM template to create the new VM from.\n"
                },
                "vga": {
                    "type": "string",
                    "description": "The video adapter the VM should use. Possible values include std and cirrus.\n"
                },
                "videoram": {
                    "type": "integer",
                    "description": "The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16\n"
                },
                "xenstore": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The key value pairs to be populated in xenstore.\n"
                }
            },
            "required": [
                "cpus",
                "disks",
                "ipv4Addresses",
                "ipv6Addresses",
                "memoryMax",
                "nameLabel",
                "networks",
                "template"
            ],
            "inputProperties": {
                "affinityHost": {
                    "type": "string",
                    "description": "The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to\nbe rescheduled.\n"
                },
                "autoPoweron": {
                    "type": "boolean",
                    "description": "If the VM will automatically turn on. Defaults to `false`.\n"
                },
                "blockedOperations": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,\nhard_shutdown, pause, shutdown, suspend, destroy. See:\nhttps://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations\n"
                },
                "cdrom": {
                    "$ref": "#/types/xenorchestra:index/VmCdrom:VmCdrom",
                    "description": "The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available\nfrom `xe template-list`) and install the OS from the following ISO.\n"
                },
                "cloneType": {
                    "type": "string",
                    "description": "The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to\nperform a `full` clone, the VM template must not be a disk template.\n"
                },
                "cloudConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init config to use. See the cloud init docs for more\n[information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n"
                },
                "cloudNetworkConfig": {
                    "type": "string",
                    "description": "The content of the cloud-init network configuration for the VM (uses [version\n1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))\n"
                },
                "coreOs": {
                    "type": "boolean"
                },
                "cpuCap": {
                    "type": "integer"
                },
                "cpuWeight": {
                    "type": "integer"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is\ngreater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects\nfilter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].CPUs' { \"max\": 4, \"number\": 2 } # Updating the VM\nto use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```\n"
                },
                "destroyCloudConfigVdiAfterBoot": {
                    "type": "boolean",
                    "description": "Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,\npower_state must be set to `Running`.\n",
                    "willReplaceOnChanges": true
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/VmDisk:VmDisk"
                    },
                    "description": "The disk the VM will have access to.\n"
                },
                "expNestedHvm": {
                    "type": "boolean",
                    "description": "Boolean parameter that allows a VM to use nested virtualization.\n"
                },
                "highAvailability": {
                    "type": "string",
                    "description": "The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.\nDefaults to empty string\n"
                },
                "host": {
                    "type": "string"
                },
                "hvmBootFirmware": {
                    "type": "string",
                    "description": "The firmware to use for the VM. Possible values are `bios` and `uefi`.\n"
                },
                "installationMethod": {
                    "type": "string",
                    "description": "This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.\n"
                },
                "memoryMax": {
                    "type": "number",
                    "description": "The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new\nvalue is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli\nxo.getAllObjects filter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].memory.dynamic' [ 2147483648, #\nmemory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without\nstopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```\n"
                },
                "nameDescription": {
                    "type": "string",
                    "description": "The description of the VM.\n"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name of the VM.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/xenorchestra:index/VmNetwork:VmNetwork"
                    },
                    "description": "The network for the VM.\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "The power state of the VM. This can be Running, Halted, Paused or Suspended.\n"
                },
                "resourceSet": {
                    "type": "string"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Number of seconds the VM should be delayed from starting.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The tags (labels) applied to the given entity.\n"
                },
                "template": {
                    "type": "string",
                    "description": "The ID of the VM template to create the new VM from.\n",
                    "willReplaceOnChanges": true
                },
                "vga": {
                    "type": "string",
                    "description": "The video adapter the VM should use. Possible values include std and cirrus.\n"
                },
                "videoram": {
                    "type": "integer",
                    "description": "The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16\n"
                },
                "xenstore": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The key value pairs to be populated in xenstore.\n"
                }
            },
            "requiredInputs": [
                "cpus",
                "disks",
                "memoryMax",
                "nameLabel",
                "networks",
                "template"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vm resources.\n",
                "properties": {
                    "affinityHost": {
                        "type": "string",
                        "description": "The preferred host you would like the VM to run on. If changed on an existing VM it will require a reboot for the VM to\nbe rescheduled.\n"
                    },
                    "autoPoweron": {
                        "type": "boolean",
                        "description": "If the VM will automatically turn on. Defaults to `false`.\n"
                    },
                    "blockedOperations": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of operations on a VM that are not permitted. Examples include: clean_reboot, clean_shutdown, hard_reboot,\nhard_shutdown, pause, shutdown, suspend, destroy. See:\nhttps://xapi-project.github.io/xen-api/classes/vm.html#enum_vm_operations\n"
                    },
                    "cdrom": {
                        "$ref": "#/types/xenorchestra:index/VmCdrom:VmCdrom",
                        "description": "The ISO that should be attached to VM. This allows you to create a VM from a diskless template (any templates available\nfrom `xe template-list`) and install the OS from the following ISO.\n"
                    },
                    "cloneType": {
                        "type": "string",
                        "description": "The type of clone to perform for the VM. Possible values include `fast` or `full` and defaults to `fast`. In order to\nperform a `full` clone, the VM template must not be a disk template.\n"
                    },
                    "cloudConfig": {
                        "type": "string",
                        "description": "The content of the cloud-init config to use. See the cloud init docs for more\n[information](https://cloudinit.readthedocs.io/en/latest/topics/examples.html).\n"
                    },
                    "cloudNetworkConfig": {
                        "type": "string",
                        "description": "The content of the cloud-init network configuration for the VM (uses [version\n1](https://cloudinit.readthedocs.io/en/latest/topics/network-config-format-v1.html))\n"
                    },
                    "coreOs": {
                        "type": "boolean"
                    },
                    "cpuCap": {
                        "type": "integer"
                    },
                    "cpuWeight": {
                        "type": "integer"
                    },
                    "cpus": {
                        "type": "integer",
                        "description": "The number of CPUs the VM will have. Updates to this field will cause a stop and start of the VM if the new CPU value is\ngreater than the max CPU value. This can be determined with the following command: ``` $ xo-cli xo.getAllObjects\nfilter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].CPUs' { \"max\": 4, \"number\": 2 } # Updating the VM\nto use 3 CPUs would happen without stopping/starting the VM # Updating the VM to use 5 CPUs would stop/start the VM ```\n"
                    },
                    "destroyCloudConfigVdiAfterBoot": {
                        "type": "boolean",
                        "description": "Determines whether the cloud config VDI should be deleted once the VM has booted. Defaults to `false`. If set to `true`,\npower_state must be set to `Running`.\n",
                        "willReplaceOnChanges": true
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/xenorchestra:index/VmDisk:VmDisk"
                        },
                        "description": "The disk the VM will have access to.\n"
                    },
                    "expNestedHvm": {
                        "type": "boolean",
                        "description": "Boolean parameter that allows a VM to use nested virtualization.\n"
                    },
                    "highAvailability": {
                        "type": "string",
                        "description": "The restart priority for the VM. Possible values are `best-effort`, `restart` and empty string (no restarts on failure.\nDefaults to empty string\n"
                    },
                    "host": {
                        "type": "string"
                    },
                    "hvmBootFirmware": {
                        "type": "string",
                        "description": "The firmware to use for the VM. Possible values are `bios` and `uefi`.\n"
                    },
                    "installationMethod": {
                        "type": "string",
                        "description": "This cannot be used with `cdrom`. Possible values are `network` which allows a VM to boot via PXE.\n"
                    },
                    "ipv4Addresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "ipv6Addresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "This is only accessible if guest-tools is installed in the VM and if `expected_ip_cidr` is set on any network\ninterfaces. This will contain a list of the ipv6 addresses across all network interfaces in order.\n"
                    },
                    "memoryMax": {
                        "type": "number",
                        "description": "The amount of memory in bytes the VM will have. Updates to this field will case a stop and start of the VM if the new\nvalue is greater than the dynamic memory max. This can be determined with the following command: ``` $ xo-cli\nxo.getAllObjects filter='json:{\"id\": \"cf7b5d7d-3cd5-6b7c-5025-5c935c8cd0b8\"}' | jq '.[].memory.dynamic' [ 2147483648, #\nmemory dynamic min 4294967296 # memory dynamic max (4GB) ] # Updating the VM to use 3GB of memory would happen without\nstopping/starting the VM # Updating the VM to use 5GB of memory would stop/start the VM ```\n"
                    },
                    "nameDescription": {
                        "type": "string",
                        "description": "The description of the VM.\n"
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name of the VM.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/xenorchestra:index/VmNetwork:VmNetwork"
                        },
                        "description": "The network for the VM.\n"
                    },
                    "powerState": {
                        "type": "string",
                        "description": "The power state of the VM. This can be Running, Halted, Paused or Suspended.\n"
                    },
                    "resourceSet": {
                        "type": "string"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Number of seconds the VM should be delayed from starting.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The tags (labels) applied to the given entity.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "The ID of the VM template to create the new VM from.\n",
                        "willReplaceOnChanges": true
                    },
                    "vga": {
                        "type": "string",
                        "description": "The video adapter the VM should use. Possible values include std and cirrus.\n"
                    },
                    "videoram": {
                        "type": "integer",
                        "description": "The videoram option the VM should use. Possible values include 1, 2, 4, 8, 16\n"
                    },
                    "xenstore": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The key value pairs to be populated in xenstore.\n"
                    }
                },
                "type": "object"
            }
        },
        "xenorchestra:index/xoaBondedNetwork:XoaBondedNetwork": {
            "description": "A resource for managing Bonded Xen Orchestra networks. See the XCP-ng [networking docs](https://xcp-ng.org/docs/networking.html) for more details.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst host1 = xenorchestra.getXoaHost({\n    nameLabel: \"Your host\",\n});\nconst eth1 = host1.then(host1 =\u003e xenorchestra.getXoaPif({\n    device: \"eth1\",\n    vlan: -1,\n    hostId: host1.id,\n}));\nconst eth2 = host1.then(host1 =\u003e xenorchestra.getXoaPif({\n    device: \"eth2\",\n    vlan: -1,\n    hostId: host1.id,\n}));\n// Create a bonded network from normal PIFs\nconst network = new xenorchestra.XoaBondedNetwork(\"network\", {\n    nameLabel: \"new network name\",\n    bondMode: \"active-backup\",\n    poolId: host1.then(host1 =\u003e host1.poolId),\n    pifIds: [\n        eth1.then(eth1 =\u003e eth1.id),\n        eth2.then(eth2 =\u003e eth2.id),\n    ],\n});\n// Create a bonded network from PIFs on VLANs\nconst eth1Vlan = host1.then(host1 =\u003e xenorchestra.getXoaPif({\n    device: \"eth1\",\n    vlan: 15,\n    hostId: host1.id,\n}));\nconst eth2Vlan = host1.then(host1 =\u003e xenorchestra.getXoaPif({\n    device: \"eth2\",\n    vlan: 15,\n    hostId: host1.id,\n}));\n// Create a bonded network from normal PIFs\nconst networkVlan = new xenorchestra.XoaBondedNetwork(\"network_vlan\", {\n    nameLabel: \"new network name\",\n    bondMode: \"active-backup\",\n    poolId: host1.then(host1 =\u003e host1.poolId),\n    pifIds: [\n        eth1Vlan.then(eth1Vlan =\u003e eth1Vlan.id),\n        eth2Vlan.then(eth2Vlan =\u003e eth2Vlan.id),\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nhost1 = xenorchestra.get_xoa_host(name_label=\"Your host\")\neth1 = xenorchestra.get_xoa_pif(device=\"eth1\",\n    vlan=-1,\n    host_id=host1.id)\neth2 = xenorchestra.get_xoa_pif(device=\"eth2\",\n    vlan=-1,\n    host_id=host1.id)\n# Create a bonded network from normal PIFs\nnetwork = xenorchestra.XoaBondedNetwork(\"network\",\n    name_label=\"new network name\",\n    bond_mode=\"active-backup\",\n    pool_id=host1.pool_id,\n    pif_ids=[\n        eth1.id,\n        eth2.id,\n    ])\n# Create a bonded network from PIFs on VLANs\neth1_vlan = xenorchestra.get_xoa_pif(device=\"eth1\",\n    vlan=15,\n    host_id=host1.id)\neth2_vlan = xenorchestra.get_xoa_pif(device=\"eth2\",\n    vlan=15,\n    host_id=host1.id)\n# Create a bonded network from normal PIFs\nnetwork_vlan = xenorchestra.XoaBondedNetwork(\"network_vlan\",\n    name_label=\"new network name\",\n    bond_mode=\"active-backup\",\n    pool_id=host1.pool_id,\n    pif_ids=[\n        eth1_vlan.id,\n        eth2_vlan.id,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var host1 = Xenorchestra.GetXoaHost.Invoke(new()\n    {\n        NameLabel = \"Your host\",\n    });\n\n    var eth1 = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth1\",\n        Vlan = -1,\n        HostId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.Id),\n    });\n\n    var eth2 = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth2\",\n        Vlan = -1,\n        HostId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.Id),\n    });\n\n    // Create a bonded network from normal PIFs\n    var network = new Xenorchestra.XoaBondedNetwork(\"network\", new()\n    {\n        NameLabel = \"new network name\",\n        BondMode = \"active-backup\",\n        PoolId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.PoolId),\n        PifIds = new[]\n        {\n            eth1.Apply(getXoaPifResult =\u003e getXoaPifResult.Id),\n            eth2.Apply(getXoaPifResult =\u003e getXoaPifResult.Id),\n        },\n    });\n\n    // Create a bonded network from PIFs on VLANs\n    var eth1Vlan = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth1\",\n        Vlan = 15,\n        HostId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.Id),\n    });\n\n    var eth2Vlan = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth2\",\n        Vlan = 15,\n        HostId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.Id),\n    });\n\n    // Create a bonded network from normal PIFs\n    var networkVlan = new Xenorchestra.XoaBondedNetwork(\"network_vlan\", new()\n    {\n        NameLabel = \"new network name\",\n        BondMode = \"active-backup\",\n        PoolId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.PoolId),\n        PifIds = new[]\n        {\n            eth1Vlan.Apply(getXoaPifResult =\u003e getXoaPifResult.Id),\n            eth2Vlan.Apply(getXoaPifResult =\u003e getXoaPifResult.Id),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thost1, err := xenorchestra.GetXoaHost(ctx, \u0026xenorchestra.GetXoaHostArgs{\n\t\t\tNameLabel: \"Your host\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\teth1, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth1\",\n\t\t\tVlan:   -1,\n\t\t\tHostId: pulumi.StringRef(host1.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\teth2, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth2\",\n\t\t\tVlan:   -1,\n\t\t\tHostId: pulumi.StringRef(host1.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a bonded network from normal PIFs\n\t\t_, err = xenorchestra.NewXoaBondedNetwork(ctx, \"network\", \u0026xenorchestra.XoaBondedNetworkArgs{\n\t\t\tNameLabel: pulumi.String(\"new network name\"),\n\t\t\tBondMode:  pulumi.String(\"active-backup\"),\n\t\t\tPoolId:    pulumi.String(host1.PoolId),\n\t\t\tPifIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(eth1.Id),\n\t\t\t\tpulumi.String(eth2.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a bonded network from PIFs on VLANs\n\t\teth1Vlan, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth1\",\n\t\t\tVlan:   15,\n\t\t\tHostId: pulumi.StringRef(host1.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\teth2Vlan, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth2\",\n\t\t\tVlan:   15,\n\t\t\tHostId: pulumi.StringRef(host1.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a bonded network from normal PIFs\n\t\t_, err = xenorchestra.NewXoaBondedNetwork(ctx, \"network_vlan\", \u0026xenorchestra.XoaBondedNetworkArgs{\n\t\t\tNameLabel: pulumi.String(\"new network name\"),\n\t\t\tBondMode:  pulumi.String(\"active-backup\"),\n\t\t\tPoolId:    pulumi.String(host1.PoolId),\n\t\t\tPifIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(eth1Vlan.Id),\n\t\t\t\tpulumi.String(eth2Vlan.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaHostArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaPifArgs;\nimport com.pulumi.xenorchestra.XoaBondedNetwork;\nimport com.pulumi.xenorchestra.XoaBondedNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var host1 = XenorchestraFunctions.getXoaHost(GetXoaHostArgs.builder()\n            .nameLabel(\"Your host\")\n            .build());\n\n        final var eth1 = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth1\")\n            .vlan(-1)\n            .hostId(host1.id())\n            .build());\n\n        final var eth2 = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth2\")\n            .vlan(-1)\n            .hostId(host1.id())\n            .build());\n\n        // Create a bonded network from normal PIFs\n        var network = new XoaBondedNetwork(\"network\", XoaBondedNetworkArgs.builder()\n            .nameLabel(\"new network name\")\n            .bondMode(\"active-backup\")\n            .poolId(host1.poolId())\n            .pifIds(            \n                eth1.id(),\n                eth2.id())\n            .build());\n\n        // Create a bonded network from PIFs on VLANs\n        final var eth1Vlan = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth1\")\n            .vlan(15)\n            .hostId(host1.id())\n            .build());\n\n        final var eth2Vlan = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth2\")\n            .vlan(15)\n            .hostId(host1.id())\n            .build());\n\n        // Create a bonded network from normal PIFs\n        var networkVlan = new XoaBondedNetwork(\"networkVlan\", XoaBondedNetworkArgs.builder()\n            .nameLabel(\"new network name\")\n            .bondMode(\"active-backup\")\n            .poolId(host1.poolId())\n            .pifIds(            \n                eth1Vlan.id(),\n                eth2Vlan.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a bonded network from normal PIFs\n  network:\n    type: xenorchestra:XoaBondedNetwork\n    properties:\n      nameLabel: new network name\n      bondMode: active-backup\n      poolId: ${host1.poolId}\n      pifIds:\n        - ${eth1.id}\n        - ${eth2.id}\n  # Create a bonded network from normal PIFs\n  networkVlan:\n    type: xenorchestra:XoaBondedNetwork\n    name: network_vlan\n    properties:\n      nameLabel: new network name\n      bondMode: active-backup\n      poolId: ${host1.poolId}\n      pifIds:\n        - ${eth1Vlan.id}\n        - ${eth2Vlan.id}\nvariables:\n  host1:\n    fn::invoke:\n      function: xenorchestra:getXoaHost\n      arguments:\n        nameLabel: Your host\n  eth1:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth1\n        vlan: -1\n        hostId: ${host1.id}\n  eth2:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth2\n        vlan: -1\n        hostId: ${host1.id}\n  # Create a bonded network from PIFs on VLANs\n  eth1Vlan:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth1\n        vlan: 15\n        hostId: ${host1.id}\n  eth2Vlan:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth2\n        vlan: 15\n        hostId: ${host1.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "automatic": {
                    "type": "boolean"
                },
                "bondMode": {
                    "type": "string",
                    "description": "The bond mode that should be used for this network.\n"
                },
                "defaultIsLocked": {
                    "type": "boolean",
                    "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU of the network. Defaults to `1500` if unspecified.\n"
                },
                "nameDescription": {
                    "type": "string"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the network.\n"
                },
                "pifIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The pifs (uuid) that should be used for this network.\n"
                },
                "poolId": {
                    "type": "string",
                    "description": "The pool id that this network should belong to.\n"
                }
            },
            "required": [
                "nameLabel",
                "poolId"
            ],
            "inputProperties": {
                "automatic": {
                    "type": "boolean"
                },
                "bondMode": {
                    "type": "string",
                    "description": "The bond mode that should be used for this network.\n",
                    "willReplaceOnChanges": true
                },
                "defaultIsLocked": {
                    "type": "boolean",
                    "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU of the network. Defaults to `1500` if unspecified.\n",
                    "willReplaceOnChanges": true
                },
                "nameDescription": {
                    "type": "string"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the network.\n"
                },
                "pifIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The pifs (uuid) that should be used for this network.\n",
                    "willReplaceOnChanges": true
                },
                "poolId": {
                    "type": "string",
                    "description": "The pool id that this network should belong to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nameLabel",
                "poolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering XoaBondedNetwork resources.\n",
                "properties": {
                    "automatic": {
                        "type": "boolean"
                    },
                    "bondMode": {
                        "type": "string",
                        "description": "The bond mode that should be used for this network.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultIsLocked": {
                        "type": "boolean",
                        "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The MTU of the network. Defaults to `1500` if unspecified.\n",
                        "willReplaceOnChanges": true
                    },
                    "nameDescription": {
                        "type": "string"
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name label of the network.\n"
                    },
                    "pifIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The pifs (uuid) that should be used for this network.\n",
                        "willReplaceOnChanges": true
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The pool id that this network should belong to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "xenorchestra:index/bondedNetwork:BondedNetwork"
                }
            ]
        },
        "xenorchestra:index/xoaNetwork:XoaNetwork": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst host1 = xenorchestra.getXoaHost({\n    nameLabel: \"Your host\",\n});\n// Create a single server network private network\nconst privateNetwork = new xenorchestra.XoaNetwork(\"private_network\", {\n    nameLabel: \"new network name\",\n    poolId: host1.then(host1 =\u003e host1.poolId),\n});\n// Create a network with a 22 VLAN tag from the eth0 device\nconst vlanNetwork = new xenorchestra.XoaNetwork(\"vlan_network\", {\n    nameLabel: \"new network name\",\n    poolId: host1.then(host1 =\u003e host1.poolId),\n    sourcePifDevice: \"eth0\",\n    vlan: 22,\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nhost1 = xenorchestra.get_xoa_host(name_label=\"Your host\")\n# Create a single server network private network\nprivate_network = xenorchestra.XoaNetwork(\"private_network\",\n    name_label=\"new network name\",\n    pool_id=host1.pool_id)\n# Create a network with a 22 VLAN tag from the eth0 device\nvlan_network = xenorchestra.XoaNetwork(\"vlan_network\",\n    name_label=\"new network name\",\n    pool_id=host1.pool_id,\n    source_pif_device=\"eth0\",\n    vlan=22)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var host1 = Xenorchestra.GetXoaHost.Invoke(new()\n    {\n        NameLabel = \"Your host\",\n    });\n\n    // Create a single server network private network\n    var privateNetwork = new Xenorchestra.XoaNetwork(\"private_network\", new()\n    {\n        NameLabel = \"new network name\",\n        PoolId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.PoolId),\n    });\n\n    // Create a network with a 22 VLAN tag from the eth0 device\n    var vlanNetwork = new Xenorchestra.XoaNetwork(\"vlan_network\", new()\n    {\n        NameLabel = \"new network name\",\n        PoolId = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.PoolId),\n        SourcePifDevice = \"eth0\",\n        Vlan = 22,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thost1, err := xenorchestra.GetXoaHost(ctx, \u0026xenorchestra.GetXoaHostArgs{\n\t\t\tNameLabel: \"Your host\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a single server network private network\n\t\t_, err = xenorchestra.NewXoaNetwork(ctx, \"private_network\", \u0026xenorchestra.XoaNetworkArgs{\n\t\t\tNameLabel: pulumi.String(\"new network name\"),\n\t\t\tPoolId:    pulumi.String(host1.PoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a network with a 22 VLAN tag from the eth0 device\n\t\t_, err = xenorchestra.NewXoaNetwork(ctx, \"vlan_network\", \u0026xenorchestra.XoaNetworkArgs{\n\t\t\tNameLabel:       pulumi.String(\"new network name\"),\n\t\t\tPoolId:          pulumi.String(host1.PoolId),\n\t\t\tSourcePifDevice: pulumi.String(\"eth0\"),\n\t\t\tVlan:            pulumi.Int(22),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaHostArgs;\nimport com.pulumi.xenorchestra.XoaNetwork;\nimport com.pulumi.xenorchestra.XoaNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var host1 = XenorchestraFunctions.getXoaHost(GetXoaHostArgs.builder()\n            .nameLabel(\"Your host\")\n            .build());\n\n        // Create a single server network private network\n        var privateNetwork = new XoaNetwork(\"privateNetwork\", XoaNetworkArgs.builder()\n            .nameLabel(\"new network name\")\n            .poolId(host1.poolId())\n            .build());\n\n        // Create a network with a 22 VLAN tag from the eth0 device\n        var vlanNetwork = new XoaNetwork(\"vlanNetwork\", XoaNetworkArgs.builder()\n            .nameLabel(\"new network name\")\n            .poolId(host1.poolId())\n            .sourcePifDevice(\"eth0\")\n            .vlan(22)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a single server network private network\n  privateNetwork:\n    type: xenorchestra:XoaNetwork\n    name: private_network\n    properties:\n      nameLabel: new network name\n      poolId: ${host1.poolId}\n  # Create a network with a 22 VLAN tag from the eth0 device\n  vlanNetwork:\n    type: xenorchestra:XoaNetwork\n    name: vlan_network\n    properties:\n      nameLabel: new network name\n      poolId: ${host1.poolId}\n      sourcePifDevice: eth0\n      vlan: 22\nvariables:\n  host1:\n    fn::invoke:\n      function: xenorchestra:getXoaHost\n      arguments:\n        nameLabel: Your host\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "automatic": {
                    "type": "boolean"
                },
                "defaultIsLocked": {
                    "type": "boolean",
                    "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU of the network. Defaults to `1500` if unspecified.\n"
                },
                "nameDescription": {
                    "type": "string"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the network.\n"
                },
                "nbd": {
                    "type": "boolean",
                    "description": "Whether the network should use a network block device. Defaults to `false` if unspecified.\n"
                },
                "poolId": {
                    "type": "string",
                    "description": "The pool id that this network should belong to.\n"
                },
                "sourcePifDevice": {
                    "type": "string",
                    "description": "The PIF device (eth0, eth1, etc) that will be used as an input during network creation. This parameter is required if a vlan is specified.\n"
                },
                "vlan": {
                    "type": "integer",
                    "description": "The vlan to use for the network. Defaults to `0` meaning no VLAN.\n"
                }
            },
            "required": [
                "nameLabel",
                "poolId"
            ],
            "inputProperties": {
                "automatic": {
                    "type": "boolean"
                },
                "defaultIsLocked": {
                    "type": "boolean",
                    "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU of the network. Defaults to `1500` if unspecified.\n",
                    "willReplaceOnChanges": true
                },
                "nameDescription": {
                    "type": "string"
                },
                "nameLabel": {
                    "type": "string",
                    "description": "The name label of the network.\n"
                },
                "nbd": {
                    "type": "boolean",
                    "description": "Whether the network should use a network block device. Defaults to `false` if unspecified.\n"
                },
                "poolId": {
                    "type": "string",
                    "description": "The pool id that this network should belong to.\n",
                    "willReplaceOnChanges": true
                },
                "sourcePifDevice": {
                    "type": "string",
                    "description": "The PIF device (eth0, eth1, etc) that will be used as an input during network creation. This parameter is required if a vlan is specified.\n",
                    "willReplaceOnChanges": true
                },
                "vlan": {
                    "type": "integer",
                    "description": "The vlan to use for the network. Defaults to `0` meaning no VLAN.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "nameLabel",
                "poolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering XoaNetwork resources.\n",
                "properties": {
                    "automatic": {
                        "type": "boolean"
                    },
                    "defaultIsLocked": {
                        "type": "boolean",
                        "description": "This argument controls whether the network should enforce VIF locking. This defaults to `false` which means that no filtering rules are applied.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The MTU of the network. Defaults to `1500` if unspecified.\n",
                        "willReplaceOnChanges": true
                    },
                    "nameDescription": {
                        "type": "string"
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name label of the network.\n"
                    },
                    "nbd": {
                        "type": "boolean",
                        "description": "Whether the network should use a network block device. Defaults to `false` if unspecified.\n"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The pool id that this network should belong to.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourcePifDevice": {
                        "type": "string",
                        "description": "The PIF device (eth0, eth1, etc) that will be used as an input during network creation. This parameter is required if a vlan is specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "vlan": {
                        "type": "integer",
                        "description": "The vlan to use for the network. Defaults to `0` meaning no VLAN.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "xenorchestra:index/network:Network"
                }
            ]
        }
    },
    "functions": {
        "xenorchestra:index/getXoaCloudConfig:getXoaCloudConfig": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\n\nconst cloudConfig = xenorchestra.getXoaCloudConfig({\n    name: \"Name of cloud config\",\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\ncloud_config = xenorchestra.get_xoa_cloud_config(name=\"Name of cloud config\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cloudConfig = Xenorchestra.GetXoaCloudConfig.Invoke(new()\n    {\n        Name = \"Name of cloud config\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := xenorchestra.GetXoaCloudConfig(ctx, \u0026xenorchestra.GetXoaCloudConfigArgs{\n\t\t\tName: \"Name of cloud config\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaCloudConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var cloudConfig = XenorchestraFunctions.getXoaCloudConfig(GetXoaCloudConfigArgs.builder()\n            .name(\"Name of cloud config\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  cloudConfig:\n    fn::invoke:\n      function: xenorchestra:getXoaCloudConfig\n      arguments:\n        name: Name of cloud config\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaCloudConfig.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the cloud config you want to look up.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaCloudConfig.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the cloud config you want to look up.\n",
                        "type": "string"
                    },
                    "template": {
                        "description": "The contents of the cloud-config.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "template",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaHost:getXoaHost": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst host1 = xenorchestra.getXoaHost({\n    nameLabel: \"Your host\",\n});\nconst node = new xenorchestra.Vm(\"node\", {affinityHost: host1.then(host1 =\u003e host1.id)});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nhost1 = xenorchestra.get_xoa_host(name_label=\"Your host\")\nnode = xenorchestra.Vm(\"node\", affinity_host=host1.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var host1 = Xenorchestra.GetXoaHost.Invoke(new()\n    {\n        NameLabel = \"Your host\",\n    });\n\n    var node = new Xenorchestra.Vm(\"node\", new()\n    {\n        AffinityHost = host1.Apply(getXoaHostResult =\u003e getXoaHostResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\thost1, err := xenorchestra.GetXoaHost(ctx, \u0026xenorchestra.GetXoaHostArgs{\n\t\t\tNameLabel: \"Your host\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"node\", \u0026xenorchestra.VmArgs{\n\t\t\tAffinityHost: pulumi.String(host1.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaHostArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var host1 = XenorchestraFunctions.getXoaHost(GetXoaHostArgs.builder()\n            .nameLabel(\"Your host\")\n            .build());\n\n        var node = new Vm(\"node\", VmArgs.builder()\n            .affinityHost(host1.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  node:\n    type: xenorchestra:Vm\n    properties:\n      affinityHost: ${host1.id}\nvariables:\n  host1:\n    fn::invoke:\n      function: xenorchestra:getXoaHost\n      arguments:\n        nameLabel: Your host\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaHost.\n",
                "properties": {
                    "nameLabel": {
                        "type": "string",
                        "description": "The name label of the host.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The tags (labels) applied to the given entity.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nameLabel"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaHost.\n",
                "properties": {
                    "cpus": {
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "description": "CPU information about the host. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "memory": {
                        "description": "The memory size of the host.\n",
                        "type": "number"
                    },
                    "memoryUsage": {
                        "description": "The memory usage of the host.\n",
                        "type": "number"
                    },
                    "nameLabel": {
                        "description": "The name label of the host.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "Id of the pool that the host belongs to.\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "The tags (labels) applied to the given entity.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "cpus",
                    "memory",
                    "memoryUsage",
                    "nameLabel",
                    "poolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaHosts:getXoaHosts": {
            "description": "Use this data source to filter Xenorchestra hosts by certain criteria (name_label, tags) for use in other resources.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaHosts.\n",
                "properties": {
                    "poolId": {
                        "type": "string",
                        "description": "The pool id used to filter the resulting hosts by.\n"
                    },
                    "sortBy": {
                        "type": "string",
                        "description": "The host field to sort the results by (id and name_label are supported).\n"
                    },
                    "sortOrder": {
                        "type": "string",
                        "description": "Valid options are `asc` or `desc` and sort order is applied to `sort_by` argument.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The tags (labels) applied to the given entity.\n"
                    }
                },
                "type": "object",
                "required": [
                    "poolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaHosts.\n",
                "properties": {
                    "hosts": {
                        "description": "The resulting hosts after applying the argument filtering.\n",
                        "items": {
                            "$ref": "#/types/xenorchestra:index/getXoaHostsHost:getXoaHostsHost"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "master": {
                        "description": "The primary host of the pool.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The pool id used to filter the resulting hosts by.\n",
                        "type": "string"
                    },
                    "sortBy": {
                        "description": "The host field to sort the results by (id and name_label are supported).\n",
                        "type": "string"
                    },
                    "sortOrder": {
                        "description": "Valid options are `asc` or `desc` and sort order is applied to `sort_by` argument.\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "The tags (labels) applied to the given entity.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "hosts",
                    "master",
                    "poolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaNetwork:getXoaNetwork": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst net = xenorchestra.getXoaNetwork({\n    nameLabel: \"Pool-wide network associated with eth0\",\n});\nconst demo_vm = new xenorchestra.Vm(\"demo-vm\", {networks: [{\n    networkId: net.then(net =\u003e net.id),\n}]});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nnet = xenorchestra.get_xoa_network(name_label=\"Pool-wide network associated with eth0\")\ndemo_vm = xenorchestra.Vm(\"demo-vm\", networks=[{\n    \"network_id\": net.id,\n}])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var net = Xenorchestra.GetXoaNetwork.Invoke(new()\n    {\n        NameLabel = \"Pool-wide network associated with eth0\",\n    });\n\n    var demo_vm = new Xenorchestra.Vm(\"demo-vm\", new()\n    {\n        Networks = new[]\n        {\n            new Xenorchestra.Inputs.VmNetworkArgs\n            {\n                NetworkId = net.Apply(getXoaNetworkResult =\u003e getXoaNetworkResult.Id),\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnet, err := xenorchestra.LookupXoaNetwork(ctx, \u0026xenorchestra.LookupXoaNetworkArgs{\n\t\t\tNameLabel: \"Pool-wide network associated with eth0\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"demo-vm\", \u0026xenorchestra.VmArgs{\n\t\t\tNetworks: xenorchestra.VmNetworkArray{\n\t\t\t\t\u0026xenorchestra.VmNetworkArgs{\n\t\t\t\t\tNetworkId: pulumi.String(net.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaNetworkArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport com.pulumi.xenorchestra.inputs.VmNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var net = XenorchestraFunctions.getXoaNetwork(GetXoaNetworkArgs.builder()\n            .nameLabel(\"Pool-wide network associated with eth0\")\n            .build());\n\n        var demo_vm = new Vm(\"demo-vm\", VmArgs.builder()\n            .networks(VmNetworkArgs.builder()\n                .networkId(net.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo-vm:\n    type: xenorchestra:Vm\n    properties:\n      networks:\n        - networkId: ${net.id}\nvariables:\n  net:\n    fn::invoke:\n      function: xenorchestra:getXoaNetwork\n      arguments:\n        nameLabel: Pool-wide network associated with eth0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaNetwork.\n",
                "properties": {
                    "bridge": {
                        "type": "string",
                        "description": "The name of the bridge network interface.\n"
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name of the network.\n"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The pool the network is associated with.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nameLabel"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaNetwork.\n",
                "properties": {
                    "bridge": {
                        "description": "The name of the bridge network interface.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameLabel": {
                        "description": "The name of the network.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The pool the network is associated with.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "bridge",
                    "nameLabel",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaPif:getXoaPif": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst eth0 = xenorchestra.getXoaPif({\n    device: \"eth0\",\n    vlan: -1,\n});\nconst demo_vm = new xenorchestra.Vm(\"demo-vm\", {networks: [{\n    networkId: eth0.then(eth0 =\u003e eth0.network),\n}]});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\neth0 = xenorchestra.get_xoa_pif(device=\"eth0\",\n    vlan=-1)\ndemo_vm = xenorchestra.Vm(\"demo-vm\", networks=[{\n    \"network_id\": eth0.network,\n}])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var eth0 = Xenorchestra.GetXoaPif.Invoke(new()\n    {\n        Device = \"eth0\",\n        Vlan = -1,\n    });\n\n    var demo_vm = new Xenorchestra.Vm(\"demo-vm\", new()\n    {\n        Networks = new[]\n        {\n            new Xenorchestra.Inputs.VmNetworkArgs\n            {\n                NetworkId = eth0.Apply(getXoaPifResult =\u003e getXoaPifResult.Network),\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\teth0, err := xenorchestra.GetXoaPif(ctx, \u0026xenorchestra.GetXoaPifArgs{\n\t\t\tDevice: \"eth0\",\n\t\t\tVlan:   -1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"demo-vm\", \u0026xenorchestra.VmArgs{\n\t\t\tNetworks: xenorchestra.VmNetworkArray{\n\t\t\t\t\u0026xenorchestra.VmNetworkArgs{\n\t\t\t\t\tNetworkId: pulumi.String(eth0.Network),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaPifArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport com.pulumi.xenorchestra.inputs.VmNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var eth0 = XenorchestraFunctions.getXoaPif(GetXoaPifArgs.builder()\n            .device(\"eth0\")\n            .vlan(-1)\n            .build());\n\n        var demo_vm = new Vm(\"demo-vm\", VmArgs.builder()\n            .networks(VmNetworkArgs.builder()\n                .networkId(eth0.network())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo-vm:\n    type: xenorchestra:Vm\n    properties:\n      networks:\n        - networkId: ${eth0.network}\nvariables:\n  eth0:\n    fn::invoke:\n      function: xenorchestra:getXoaPif\n      arguments:\n        device: eth0\n        vlan: -1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaPif.\n",
                "properties": {
                    "device": {
                        "type": "string",
                        "description": "The name of the network device. Examples include eth0, eth1, etc. See `ifconfig` for possible devices.\n"
                    },
                    "hostId": {
                        "type": "string",
                        "description": "The ID of the host that the PIF belongs to.\n"
                    },
                    "vlan": {
                        "type": "integer",
                        "description": "The VLAN the PIF belongs to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "device",
                    "vlan"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaPif.\n",
                "properties": {
                    "attached": {
                        "description": "If the PIF is attached to the network.\n",
                        "type": "boolean"
                    },
                    "device": {
                        "description": "The name of the network device. Examples include eth0, eth1, etc. See `ifconfig` for possible devices.\n",
                        "type": "string"
                    },
                    "host": {
                        "description": "The host the PIF is associated with.\n",
                        "type": "string"
                    },
                    "hostId": {
                        "description": "The ID of the host that the PIF belongs to.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "network": {
                        "description": "The network the PIF is associated with.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The pool the PIF is associated with.\n",
                        "type": "string"
                    },
                    "uuid": {
                        "description": "The uuid of the PIF.\n",
                        "type": "string"
                    },
                    "vlan": {
                        "description": "The VLAN the PIF belongs to.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "attached",
                    "device",
                    "host",
                    "hostId",
                    "network",
                    "poolId",
                    "uuid",
                    "vlan",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaPool:getXoaPool": {
            "description": "Provides information about a pool.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\n\nconst pool = xenorchestra.getXoaPool({\n    nameLabel: \"Your pool\",\n});\nconst localStorage = pool.then(pool =\u003e xenorchestra.getXoaStorageRepository({\n    nameLabel: \"Your storage repository label\",\n    poolId: pool.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\npool = xenorchestra.get_xoa_pool(name_label=\"Your pool\")\nlocal_storage = xenorchestra.get_xoa_storage_repository(name_label=\"Your storage repository label\",\n    pool_id=pool.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = Xenorchestra.GetXoaPool.Invoke(new()\n    {\n        NameLabel = \"Your pool\",\n    });\n\n    var localStorage = Xenorchestra.GetXoaStorageRepository.Invoke(new()\n    {\n        NameLabel = \"Your storage repository label\",\n        PoolId = pool.Apply(getXoaPoolResult =\u003e getXoaPoolResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tpool, err := xenorchestra.GetXoaPool(ctx, \u0026xenorchestra.GetXoaPoolArgs{\n\t\t\tNameLabel: \"Your pool\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.GetXoaStorageRepository(ctx, \u0026xenorchestra.GetXoaStorageRepositoryArgs{\n\t\t\tNameLabel: \"Your storage repository label\",\n\t\t\tPoolId:    pulumi.StringRef(pool.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaPoolArgs;\nimport com.pulumi.xenorchestra.inputs.GetXoaStorageRepositoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pool = XenorchestraFunctions.getXoaPool(GetXoaPoolArgs.builder()\n            .nameLabel(\"Your pool\")\n            .build());\n\n        final var localStorage = XenorchestraFunctions.getXoaStorageRepository(GetXoaStorageRepositoryArgs.builder()\n            .nameLabel(\"Your storage repository label\")\n            .poolId(pool.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  pool:\n    fn::invoke:\n      function: xenorchestra:getXoaPool\n      arguments:\n        nameLabel: Your pool\n  localStorage:\n    fn::invoke:\n      function: xenorchestra:getXoaStorageRepository\n      arguments:\n        nameLabel: Your storage repository label\n        poolId: ${pool.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaPool.\n",
                "properties": {
                    "nameLabel": {
                        "type": "string",
                        "description": "The name_label of the pool to look up.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nameLabel"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaPool.\n",
                "properties": {
                    "cpus": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "CPU information about the pool. The 'cores' key will contain the number of cpu cores and the 'sockets' key will contain the number of sockets.\n",
                        "type": "object"
                    },
                    "description": {
                        "description": "The description of the pool.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "master": {
                        "description": "The id of the primary instance in the pool.\n",
                        "type": "string"
                    },
                    "nameLabel": {
                        "description": "The name_label of the pool to look up.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cpus",
                    "description",
                    "master",
                    "nameLabel",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaResourceSet:getXoaResourceSet": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\n\nconst rs = xenorchestra.getXoaResourceSet({\n    name: \"my resource set\",\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nrs = xenorchestra.get_xoa_resource_set(name=\"my resource set\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rs = Xenorchestra.GetXoaResourceSet.Invoke(new()\n    {\n        Name = \"my resource set\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := xenorchestra.GetXoaResourceSet(ctx, \u0026xenorchestra.GetXoaResourceSetArgs{\n\t\t\tName: \"my resource set\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaResourceSetArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var rs = XenorchestraFunctions.getXoaResourceSet(GetXoaResourceSetArgs.builder()\n            .name(\"my resource set\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  rs:\n    fn::invoke:\n      function: xenorchestra:getXoaResourceSet\n      arguments:\n        name: my resource set\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaResourceSet.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the resource set to look up.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaResourceSet.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the resource set to look up.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaStorageRepository:getXoaStorageRepository": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst localStorage = xenorchestra.getXoaStorageRepository({\n    nameLabel: \"Your storage repository label\",\n});\nconst demo_vm = new xenorchestra.Vm(\"demo-vm\", {disks: [{\n    srId: localStorage.then(localStorage =\u003e localStorage.id),\n    nameLabel: \"Ubuntu Bionic Beaver 18.04_imavo\",\n    size: 32212254720,\n}]});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nlocal_storage = xenorchestra.get_xoa_storage_repository(name_label=\"Your storage repository label\")\ndemo_vm = xenorchestra.Vm(\"demo-vm\", disks=[{\n    \"sr_id\": local_storage.id,\n    \"name_label\": \"Ubuntu Bionic Beaver 18.04_imavo\",\n    \"size\": 32212254720,\n}])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var localStorage = Xenorchestra.GetXoaStorageRepository.Invoke(new()\n    {\n        NameLabel = \"Your storage repository label\",\n    });\n\n    var demo_vm = new Xenorchestra.Vm(\"demo-vm\", new()\n    {\n        Disks = new[]\n        {\n            new Xenorchestra.Inputs.VmDiskArgs\n            {\n                SrId = localStorage.Apply(getXoaStorageRepositoryResult =\u003e getXoaStorageRepositoryResult.Id),\n                NameLabel = \"Ubuntu Bionic Beaver 18.04_imavo\",\n                Size = 32212254720,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tlocalStorage, err := xenorchestra.GetXoaStorageRepository(ctx, \u0026xenorchestra.GetXoaStorageRepositoryArgs{\n\t\t\tNameLabel: \"Your storage repository label\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"demo-vm\", \u0026xenorchestra.VmArgs{\n\t\t\tDisks: xenorchestra.VmDiskArray{\n\t\t\t\t\u0026xenorchestra.VmDiskArgs{\n\t\t\t\t\tSrId:      pulumi.String(localStorage.Id),\n\t\t\t\t\tNameLabel: pulumi.String(\"Ubuntu Bionic Beaver 18.04_imavo\"),\n\t\t\t\t\tSize:      pulumi.Float64(32212254720),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaStorageRepositoryArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport com.pulumi.xenorchestra.inputs.VmDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var localStorage = XenorchestraFunctions.getXoaStorageRepository(GetXoaStorageRepositoryArgs.builder()\n            .nameLabel(\"Your storage repository label\")\n            .build());\n\n        var demo_vm = new Vm(\"demo-vm\", VmArgs.builder()\n            .disks(VmDiskArgs.builder()\n                .srId(localStorage.id())\n                .nameLabel(\"Ubuntu Bionic Beaver 18.04_imavo\")\n                .size(32212254720.0)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo-vm:\n    type: xenorchestra:Vm\n    properties:\n      disks:\n        - srId: ${localStorage.id}\n          nameLabel: Ubuntu Bionic Beaver 18.04_imavo\n          size: 3.221225472e+10\nvariables:\n  localStorage:\n    fn::invoke:\n      function: xenorchestra:getXoaStorageRepository\n      arguments:\n        nameLabel: Your storage repository label\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaStorageRepository.\n",
                "properties": {
                    "nameLabel": {
                        "type": "string",
                        "description": "The name of the storage repository to look up\n"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The Id of the pool the storage repository exists on.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The tags (labels) applied to the given entity.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nameLabel"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaStorageRepository.\n",
                "properties": {
                    "container": {
                        "description": "The storage container.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameLabel": {
                        "description": "The name of the storage repository to look up\n",
                        "type": "string"
                    },
                    "physicalUsage": {
                        "description": "The physical storage size.\n",
                        "type": "number"
                    },
                    "poolId": {
                        "description": "The Id of the pool the storage repository exists on.\n",
                        "type": "string"
                    },
                    "size": {
                        "description": "The storage size.\n",
                        "type": "number"
                    },
                    "srType": {
                        "description": "The type of storage repository (lvm, udev, iso, user, etc).\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "The tags (labels) applied to the given entity.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "usage": {
                        "description": "The current usage for this storage repository.\n",
                        "type": "number"
                    },
                    "uuid": {
                        "description": "uuid of the storage repository. This is equivalent to the id.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "container",
                    "nameLabel",
                    "physicalUsage",
                    "size",
                    "srType",
                    "usage",
                    "uuid",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaTemplate:getXoaTemplate": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\nimport * as xenorchestra from \"@vates/pulumi-xenorchestra\";\n\nconst template = xenorchestra.getXoaTemplate({\n    nameLabel: \"Ubuntu Bionic Beaver 18.04\",\n});\nconst demo_vm = new xenorchestra.Vm(\"demo-vm\", {template: template.then(template =\u003e template.id)});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\ntemplate = xenorchestra.get_xoa_template(name_label=\"Ubuntu Bionic Beaver 18.04\")\ndemo_vm = xenorchestra.Vm(\"demo-vm\", template=template.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var template = Xenorchestra.GetXoaTemplate.Invoke(new()\n    {\n        NameLabel = \"Ubuntu Bionic Beaver 18.04\",\n    });\n\n    var demo_vm = new Xenorchestra.Vm(\"demo-vm\", new()\n    {\n        Template = template.Apply(getXoaTemplateResult =\u003e getXoaTemplateResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttemplate, err := xenorchestra.GetXoaTemplate(ctx, \u0026xenorchestra.GetXoaTemplateArgs{\n\t\t\tNameLabel: \"Ubuntu Bionic Beaver 18.04\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = xenorchestra.NewVm(ctx, \"demo-vm\", \u0026xenorchestra.VmArgs{\n\t\t\tTemplate: pulumi.String(template.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaTemplateArgs;\nimport com.pulumi.xenorchestra.Vm;\nimport com.pulumi.xenorchestra.VmArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var template = XenorchestraFunctions.getXoaTemplate(GetXoaTemplateArgs.builder()\n            .nameLabel(\"Ubuntu Bionic Beaver 18.04\")\n            .build());\n\n        var demo_vm = new Vm(\"demo-vm\", VmArgs.builder()\n            .template(template.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo-vm:\n    type: xenorchestra:Vm\n    properties:\n      template: ${template.id}\nvariables:\n  template:\n    fn::invoke:\n      function: xenorchestra:getXoaTemplate\n      arguments:\n        nameLabel: Ubuntu Bionic Beaver 18.04\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaTemplate.\n",
                "properties": {
                    "nameLabel": {
                        "type": "string",
                        "description": "The name of the template to look up.\n"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The id of the pool that the template belongs to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "nameLabel"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaTemplate.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameLabel": {
                        "description": "The name of the template to look up.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The id of the pool that the template belongs to.\n",
                        "type": "string"
                    },
                    "uuid": {
                        "description": "The uuid of the template.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "nameLabel",
                    "uuid",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaUser:getXoaUser": {
            "description": "Provides information about a Xen Orchestra user. If the Xen Orchestra user account you are using is not an admin, see the `search_in_session` parameter.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as xenorchestra from \"@pulumi/xenorchestra\";\n\nconst user = xenorchestra.getXoaUser({\n    username: \"my-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_xenorchestra as xenorchestra\n\nuser = xenorchestra.get_xoa_user(username=\"my-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Xenorchestra = Pulumi.Xenorchestra;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = Xenorchestra.GetXoaUser.Invoke(new()\n    {\n        Username = \"my-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/vatesfr/pulumi-xenorchestra/sdk/v2/go/xenorchestra\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := xenorchestra.GetXoaUser(ctx, \u0026xenorchestra.GetXoaUserArgs{\n\t\t\tUsername: \"my-username\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.xenorchestra.XenorchestraFunctions;\nimport com.pulumi.xenorchestra.inputs.GetXoaUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var user = XenorchestraFunctions.getXoaUser(GetXoaUserArgs.builder()\n            .username(\"my-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  user:\n    fn::invoke:\n      function: xenorchestra:getXoaUser\n      arguments:\n        username: my-username\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaUser.\n",
                "properties": {
                    "searchInSession": {
                        "type": "boolean",
                        "description": "A boolean which will search for the user in the current session (`session.getUser` Xen Orchestra RPC call). This allows a non admin user to look up their own user account.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the XO user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaUser.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "searchInSession": {
                        "description": "A boolean which will search for the user in the current session (`session.getUser` Xen Orchestra RPC call). This allows a non admin user to look up their own user account.\n",
                        "type": "boolean"
                    },
                    "username": {
                        "description": "The username of the XO user.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaVdi:getXoaVdi": {
            "description": "## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaVdi.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the VDI.\n"
                    },
                    "nameLabel": {
                        "type": "string",
                        "description": "The name of the VDI to look up.\n"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The ID of the pool the VDI belongs to. This is useful if you have a VDI with the same name on different pools.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The tags (labels) applied to the given entity.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getXoaVdi.\n",
                "properties": {
                    "id": {
                        "description": "The ID of the VDI.\n",
                        "type": "string"
                    },
                    "nameLabel": {
                        "description": "The name of the VDI to look up.\n",
                        "type": "string"
                    },
                    "parent": {
                        "description": "The ID of the parent VDI if one exists. An example of when a VDI will have a parent is when it was created from a VM fast clone.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The ID of the pool the VDI belongs to. This is useful if you have a VDI with the same name on different pools.\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "The tags (labels) applied to the given entity.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id",
                    "parent"
                ],
                "type": "object"
            }
        },
        "xenorchestra:index/getXoaVms:getXoaVms": {
            "description": "Use this data source to filter Xenorchestra VMs by certain criteria (pool_id, power_state or host) for use in other resources.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getXoaVms.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "poolId": {
                        "type": "string",
                        "description": "The ID of the pool the VM belongs to.\n"
                    },
                    "powerState": {
                        "type": "string",
                        "description": "The power state of the vms. (Running, Halted)\n"
                    }
                },
                "type": "object",
                "required": [
                    "poolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getXoaVms.\n",
                "properties": {
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "poolId": {
                        "description": "The ID of the pool the VM belongs to.\n",
                        "type": "string"
                    },
                    "powerState": {
                        "description": "The power state of the vms. (Running, Halted)\n",
                        "type": "string"
                    },
                    "vms": {
                        "description": "A list of information for all vms found in this pool.\n",
                        "items": {
                            "$ref": "#/types/xenorchestra:index/getXoaVmsVm:getXoaVmsVm"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "poolId",
                    "vms",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}